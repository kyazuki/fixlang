module Main;

and : Bool -> Bool -> Bool;
and = \lhs -> \rhs -> (
    if lhs 
        then if rhs then true else false
        else false
);

/*
type Pair a b = struct (fst: a, snd: b);

impl [a: Eq, b: Eq] Pair a b : Eq {
    eq = \lhs -> \rhs -> (
        (lhs.get_fst == rhs.get_fst).and (lhs.get_snd == rhs.get_snd)
    );
}
*/

type IntVec = struct (x: Int, y: Int);

impl IntVec : Eq {
    eq = \lhs -> \rhs -> (
        (lhs.get_x == rhs.get_x).and (lhs.get_y == rhs.get_y)
    );
}

search : [a: Eq] a -> Array a -> Int;
search = \elem -> \arr -> loop 0 \idx -> (
    if idx == arr.len then break -1
    else if eq elem (arr.get idx) then break idx
    else continue (idx + 1)
);

main : Int;
main = (
    let arr = Array.new 5 $ IntVec.new 0 0;
    let arr = arr.set 1 $ IntVec.new 1 1;
    let arr = arr.set 2 $ IntVec.new 2 2;
    let arr = arr.set 3 $ IntVec.new 3 3;
    let arr = arr.set 4 $ IntVec.new 4 4;
    arr.search $ IntVec.new 2 2   // evaluates to 2
);  