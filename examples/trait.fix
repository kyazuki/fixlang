module Main;

/*
Eq trait is defined in standard library as follows: 

trait a: Eq {
    eq: a -> a -> Bool
}

Expression `x == y` is interpreted as `Eq.eq(x, y)`.
*/

type Pair a b = struct { fst: a, snd: b };

// In the trait implementation, you can specify assumptions of the trait in the `[]` bracket after `impl`.
impl [a: Eq, b: Eq] Pair a b : Eq {
    eq = |lhs, rhs| (
        lhs.@fst == rhs.@fst && lhs.@snd == rhs.@snd
    );
}

// Also, you can specify assumptions of the type of a symbol (= module-level global value) 
// in the `[]` bracket before the type signature.
search : [a: Eq] a -> Array a -> I64;
search = |elem, arr| loop(0, |idx|
    if idx == arr.get_size { break $ -1 };
    if arr.@(idx) == elem { break $ idx };
    continue $ (idx + 1)
);

// An example of higher-kinded trait.
// All type variable has kind `*` by default, and any kind of higher-kinded type variable need to be annoted explicitly.
trait [f:*->*] f : MyFunctor {
    mymap : (a -> b) -> f a -> f b;
}

impl Array : MyFunctor {
    mymap = |f, arr| (
        Array::from_map(arr.get_size, |idx| f(arr.@(idx)))
    );
}

main : IO ();
main = (
    let arr = Array::from_map(6, |x| x); // arr = [0,1,2,...,9].
    let arr = arr.mymap(|x| Pair { fst: x % 2, snd: x % 3 }); // arr = [(0, 0), (1, 1), (0, 2), ...].
    println $ arr.search(Pair { fst: 1, snd: 2}).to_string // 5, the first number x such that x % 2 == 1 and x % 3 == 2.
);