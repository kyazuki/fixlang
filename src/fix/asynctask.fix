module AsyncTask;
// This module provides a way to run a task asynchronously.
// 
// Importing this module automatically enables `--threaded` flag of the compiler. 
// Note that this causes some overhead even for a single-threaded program.

// A type for a computation task that can be run asynchronously.
type Task a = unbox struct { dtor : Destructor (Ptr, TaskData a) };

// A type to store a task and its result. 
// This type should be used only by implementation of this library.
type TaskData a = box struct {
    _func : () -> Array a, // We need a type of boxed `Option`, and actually we use `Array` of length at most one instead.
    _result : Array a
};

// Get the result of a computation task.
// This function blocks the current thread until the task is finished.
get : Task a -> a;
get = |task| (
    let (task_handle, task_data) = task.@dtor.@value;
    eval CALL_C[() fixruntime_threadpool_wait_task(Ptr), task_handle];
    eval task; // Do not call destructor of `task` before calling `fixruntime_threadpool_wait_task`, or otherwise the task will be canceled.
    task_data.@_result.@(0) // TODO: Change this to _unsafe_get_unchecked.
);

// Make a task which performs a computation asynchronously.

// Example:
// ```
// module Main;
// import AsyncTask;
// import Debug;

// main : IO ();
// main = (
//     let sum_range = |from, to| (
//         loop((0, from), |(sum, i)| (
//             if i == to { break $ sum };
//             continue $ (sum + i, i + 1)
//         ))
//     );
//     let n = 1000000000;
//     // Compute the sum of numbers from 0 to n/2 - 1.
//     // This task will be executed asynchronously (if you are using multi-core CPU).
//     let sum_former = AsyncTask::make(TaskPolicy::default, |_| sum_range(0, n/2));
//     // Compute the sum of numbers from n/2 to n.
//     // We perfom this in the current thread while waiting for the result of the former task.
//     let sum_latter = sum_range(n/2, n);
//     // Sum up the results of the two computations.
//     let sum = sum_former.get + sum_latter;
//     // Then the sum should be n * (n - 1) / 2.
//     eval assert_eq(|_|"", sum, n * (n - 1) / 2);
//     println $ 
//         "Sum of numbers from 0 to " + (n - 1).to_string + 
//         " is " + sum_former.get.to_string + " + " + sum_latter.to_string + 
//         " = " + sum.to_string + "."
// );
// ```
make : TaskPolicy -> (() -> a) -> Task a;
make = |policy, func| (
    // Create TaskData.
    let func = mark_threaded(func);
    let task_data = TaskData { _func : |_| [func()], _result : [] };

    // Get task handle issued by the runtime by cloning (retaining) the task data.
    let task_handle = CALL_C[Ptr fixruntime_threadpool_create_task(Ptr, Ptr, U32), 
        task_data.unsafe_get_retained_ptr_of_boxed_value,
        task_data.unsafe_get_release_function_of_boxed_value,
        policy
    ];

    // In the destructor, release the task handle.
    let dtor = Destructor::make((task_handle, task_data), |(task_handle, task_data)| (
        CALL_C[() fixruntime_threadpool_release_task(Ptr), task_handle]
    ));
    Task { dtor : dtor }
);

// Get the number of processors (CPU cores) currently available.
// This is implemented by calling `sysconf(_SC_NPROCESSORS_ONLN)`.
// The runtime pools as many threads as this number to execute asynchronous tasks.
number_of_processors : I64;
number_of_processors = CALL_C[I64 fixruntime_get_number_of_processors()];

namespace AsyncIOTask {

    // A type for an I/O action that can be run asynchronously.
    type IOTask a = unbox struct { _task : Task a };

    // Get the result of an asynchronous I/O action.
    get : IOTask a -> IO a;
    get = |IOTask { _task : task }| IO { _data : |_| task.get };

    // An `IO` version of `AsyncTask::make`.
    // 
    // Example:
    // ```
    // module Main;
    // import AsyncTask;
    // 
    // main : IO ();
    // main = (
    //     let print_ten : I64 -> IO () = |task_num| (
    //         loop_m(0, |i| (
    //             if i == 10 {
    //                 break_m $ ()
    //             } else {
    //                 let msg = "task number: " + task_num.to_string + ", i: " + i.to_string;
    //                 eval *msg.println;
    //                 continue_m $ i + 1
    //             }
    //         ))
    //     );
    //     eval *AsyncIOTask::make(TaskPolicy::run_after_destructed, print_ten(0));
    //     eval *AsyncIOTask::make(TaskPolicy::run_after_destructed, print_ten(1));
    //     pure()
    // );
    // ```
    make : TaskPolicy -> IO a -> IO (IOTask a);
    make = |policy, io| (
        // NOTE: we must not create AsyncTask in this function; we should create it in the IO action.
        // Otherwise, user can run IO action in a pure function.
        // So we cannot implement this function as `pure $ IOTask { ... }`.
        IO { _data : |_| IOTask { _task : make(policy, |_| io._unsafe_perform) } }
    );
}

namespace TaskPolicy {
    // A type to represent how a task should be executed.
    // This is a type alias of `U32` and used as bit flag: mask values are defined in namespace `TaskPolicy`.
    type TaskPolicy = U32;

    // Default task policy.
    default : TaskPolicy;
    default = 0_U32;

    // By default policy, a task will be canceled when the task object is destructed.
    // This task policy runs the task even after the task object is destructed.
    run_after_destructed : TaskPolicy;
    run_after_destructed = 1_U32.shift_left(1_U32);

    // By default policy, a task will be executed on a thread in the thread pool.
    // This task policy runs the task on a dedicated thread.
    on_dedicated_thread : TaskPolicy;
    on_dedicated_thread = 1_U32.shift_left(0_U32);
}

namespace Var {
    // A type of variable which can be modified from multiple threads.
    type Var a = unbox struct { _dtor : Destructor VarHandle };

    type VarHandle = Ptr;

    // Get a value stored in a `Var`.
    get : Var a -> IO a;
    get = |Var { _dtor : dtor }| IO { _data : |_| (
        let handle = dtor.@value;
        eval CALL_C[() fixruntime_threadpool_var_lock(Ptr), handle];
        let ptr = CALL_C[Ptr fixruntime_threadpool_var_get(Ptr), handle];
        eval CALL_C[() fixruntime_threadpool_var_unlock(Ptr), handle];
        eval dtor; // Do not call destructor before ending working with handle.
        ptr.unsafe_get_boxed_value_from_retained_ptr
    ) };

    // `var.lock(act)` performs an action on the value in `var` while locking `var` to prevent it from being changed by another thread.
    lock : (a -> IO b) -> Var a -> IO b;
    lock = |act, Var { _dtor : dtor }| IO { _data : |_| (
        let handle = dtor.@value;
        eval CALL_C[() fixruntime_threadpool_var_lock(Ptr), handle];
        let ptr = CALL_C[Ptr fixruntime_threadpool_var_get(Ptr), handle];
        let res = act(ptr.unsafe_get_boxed_value_from_retained_ptr)._unsafe_perform; 
        eval CALL_C[() fixruntime_threadpool_var_unlock(Ptr), handle];
        eval dtor; // Do not call destructor before ending working with handle.
        res
    ) };

    // Create a new `Var` object.
    make : a -> Var a;
    make = |value| (
        let handle = CALL_C[Ptr fixruntime_threadpool_var_create(Ptr, Ptr, Ptr), 
            value.unsafe_get_retained_ptr_of_boxed_value,
            value.unsafe_get_release_function_of_boxed_value,
            value.unsafe_get_retain_function_of_boxed_value
        ];
        let dtor = Destructor::make(handle, |handle| (
            CALL_C[() fixruntime_threadpool_var_destroy(Ptr), handle]
        ));
        Var { _dtor : dtor }
    );

    // Atomically modifies a value in a `Var`.
    mod : (a -> a) -> Var a -> IO ();
    mod = |act, var| var.lock(|val| var.set(act(val)));

    // Set a value to a `Var`.
    set : a -> Var a -> IO ();
    set = |value, Var { _dtor : dtor }| IO { _data : |_| (
        let ptr = value.unsafe_get_retained_ptr_of_boxed_value;
        let handle = dtor.@value;
        eval CALL_C[() fixruntime_threadpool_var_lock(Ptr), handle];
        eval CALL_C[() fixruntime_threadpool_var_set(Ptr), ptr];
        eval CALL_C[() fixruntime_threadpool_var_signalall(Ptr), handle];
        eval CALL_C[() fixruntime_threadpool_var_unlock(Ptr), handle];
        eval dtor; // Do not call destructor before ending working with handle.
        ()
    ) };

    // `var.wait_and_lock(cond, act)` waits until `cond` on the value of `var` is satisfied, 
    // then performs `act` on the value in `var` while locking `var` to prevent it from being changed by another thread.
    wait_and_lock : (a -> Bool) -> (a -> IO b) -> Var a -> IO b;
    wait_and_lock = |cond, act, Var { _dtor : dtor }| IO { _data : |_| (
        let handle = dtor.@value;
        eval CALL_C[() fixruntime_threadpool_var_lock(Ptr), handle];
        let ok_val = loop((), |_| (
            let ptr = CALL_C[Ptr fixruntime_threadpool_var_get(Ptr), handle];
            let val = ptr.unsafe_get_boxed_value_from_retained_ptr;
            if cond(val) {
                break $ val
            } else {
                eval CALL_C[() fixruntime_threadpool_var_wait(Ptr), handle];
                continue $ ()
            }
        ));
        let res = act(ok_val)._unsafe_perform;
        eval CALL_C[() fixruntime_threadpool_var_unlock(Ptr), handle];
        eval dtor; // Do not call destructor before ending working with handle.
        res
    ) };
}