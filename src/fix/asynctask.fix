module AsyncTask;
// This module provides a way to run a task asynchronously.
// 
// Parallel nor preemptive multitasking is expected but not guaranteed.
// When a thread starts to wait the result of a task which is still not running, then it will be executed in the waiting thread itself.
// 
// Importing this module automatically enables `--threaded` flag of the compiler. 
// Note that this causes some overhead even for a single-threaded program.

// A type for a computation task that can be run asynchronously.
type Task a = unbox struct { dtor : Destructor (Ptr, TaskData a) };

// A type to store a task and its result. 
// This type should be used only by implementation of this library.
// TODO: We can change this to enum to release task function earlier.
type TaskData a = box struct {
    _func : () -> Array a, // We need a type of boxed `Option`, and actually we use `Array` of length at most one instead.
    _result : Array a
};

// Get the result of a computation task.
// This function blocks the current thread until the task is finished.
get : Task a -> a;
get = |task| (
    let (task_handle, task_data) = task.@dtor.@value;
    eval CALL_C[() fixruntime_threadpool_wait_task(Ptr), task_handle];
    eval task; // Do not call destructor of `task` before calling `fixruntime_threadpool_wait_task`.
    task_data.@_result.@(0) // Change this to _unsafe_get_unchecked.
);

// Make a task which performs a computation asynchronously.
// The task is queued and will be executed in a thread later.

// Example:
// ```
// module Main;
// import AsyncTask;
// import Debug;

// main : IO ();
// main = (
//     let sum_range = |from, to| (
//         loop((0, from), |(sum, i)| (
//             if i == to { break $ sum };
//             continue $ (sum + i, i + 1)
//         ))
//     );
//     let n = 1000000000;
//     // Compute the sum of numbers from 0 to n/2 - 1.
//     // This task will be executed asynchronously (if you are using multi-core CPU).
//     let sum_former = AsyncTask::make(|_| sum_range(0, n/2));
//     // Compute the sum of numbers from n/2 to n.
//     // We perfom this in the current thread while waiting for the result of the former task.
//     let sum_latter = sum_range(n/2, n);
//     // Sum up the results of the two computations.
//     let sum = sum_former.get + sum_latter;
//     // Then the sum should be n * (n - 1) / 2.
//     eval assert_eq(|_|"", sum, n * (n - 1) / 2);
//     println $ 
//         "Sum of numbers from 0 to " + (n - 1).to_string + 
//         " is " + sum_former.get.to_string + " + " + sum_latter.to_string + 
//         " = " + sum.to_string + "."
// );
// ```
make : (() -> a) -> Task a;
make = |func| (
    let func = mark_threaded(func);
    let task_data = TaskData { _func : |_| [func()], _result : [] };
    let task_handle = CALL_C[Ptr fixruntime_threadpool_create_task(Ptr), task_data._unsafe_get_ptr_of_boxed_value];
    let dtor = Destructor::make((task_handle, task_data), |(task_handle, task_data)| (
        eval CALL_C[() fixruntime_threadpool_delete_task(Ptr), task_handle];
        eval task_data; // Do not deallocate `task_data` before calling `fixruntime_threadpool_delete_task`.
        ()
    ));
    Task { dtor : dtor }
);

namespace AsyncIOTask {

    // A type for an I/O action that can be run asynchronously.
    type IOTask a = unbox struct { _task : Task a };

    // Get the result of an asynchronous I/O action.
    get : IOTask a -> IO a;
    get = |IOTask { _task : task }| IO { _data : |_| task.get };

    // Make a task which performs an I/O action asynchronously.
    make : IO a -> IOTask a;
    make = |io| IOTask { _task : make(|_| io._unsafe_perform) };

}

// Get the number of processors (CPU cores) currently available.
// This is implemented by calling `sysconf(_SC_NPROCESSORS_ONLN)`.
// The runtime pools as many threads as this number to execute asynchronous tasks.
number_of_processors : I64;
number_of_processors = CALL_C[I64 fixruntime_get_number_of_processors()];