module AsyncTask;
// This module provides a way to run a computation asynchronously.
// Importing this module automatically enables `--threaded` flag of the compiler. 
// Note that this causes some overhead even for a single-threaded program.

// A type for a task that can be run asynchronously.
type Task a = unbox struct { dtor : Destructor (Ptr, TaskData a) };

// A type to store a task and its result. 
// This type should be used only by implementation of this library.
type TaskData a = box struct {
    _func : () -> Array a, // We need a type of boxed `Option`, and actually we use `Array` of length at most one instead.
    _result : Array a
};

// Make a task for a computation.
make : (() -> a) -> Task a;
make = |func| (
    let func = mark_threaded(func);
    let task_data = TaskData { _func : |_| [func()], _result : [] };
    let task_handle = CALL_C[Ptr fixruntime_threadpool_create_task(Ptr), task_data._unsafe_get_ptr_of_boxed_value];
    let dtor = Destructor::make((task_handle, task_data), |(task_handle, task_data)| (
        eval CALL_C[() fixruntime_threadpool_delete_task(Ptr), task_handle];
        eval task_data; // Do not deallocate `task_data` before calling `fixruntime_threadpool_delete_task`.
        ()
    ));
    Task { dtor : dtor }
);

// Get the result of a computation task.
get : Task a -> a;
get = |task| (
    let (task_handle, task_data) = task.@dtor.@value;
    eval CALL_C[() fixruntime_threadpool_wait_task(Ptr), task_handle];
    eval task; // Do not deallocate `task` before calling `fixruntime_threadpool_wait_task`.
    task_data.@_result.@(0) // TODO: change this to unsafe_get.
);