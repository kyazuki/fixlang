// === Basic rules ===
sep = _{ " " | "\t" | NEWLINE | block_comment | line_comment }

expr_int_lit = { "-"? ~ ASCII_DIGIT ~ ASCII_DIGIT* }

expr_bool_lit = { "true" | "false" }

expr_lit = { expr_int_lit | expr_bool_lit }

keywords = _{ "let" | "in" | "if" | "then" | "else" | "for" | expr_bool_lit | "type" | "trait" | "impl" }

in_of_let = { "in" | ";" }

eq_of_let = { "=" }

arrow_of_lam = { "->" }

var_char = _{ ASCII_ALPHA | ASCII_DIGIT }

var = { !keywords ~ (ASCII_ALPHA_LOWER ~ var_char* ~ "!"? ) }

var_with_type = { var ~ (sep* ~ ":" ~ sep* ~ type_expr)? }

// === Expressions ===

namespace_item = { ASCII_ALPHA_UPPER ~ var_char* }

namespace = { (namespace_item ~ ".")* }

expr_var = { namespace ~ var }

expr_let = { "let" ~ sep+ ~ var_with_type ~ sep* ~ eq_of_let ~ sep* ~ expr ~ sep* ~ in_of_let ~ sep* ~ expr }

expr_if = { "if" ~ sep+ ~ expr ~ sep+ ~ "then" ~ sep+ ~ expr ~ sep+ ~ "else" ~ sep+ ~ expr }

expr_lam = { "\\" ~ sep* ~ var ~ sep*  ~ arrow_of_lam ~ sep* ~ expr }

expr_braced = { "(" ~ sep* ~ expr ~ sep* ~ ")" }

// nlr = non left recursive
expr_nlr = { expr_lit | expr_var | expr_let | expr_if | expr_lam | expr_braced }

// application sequence, e.g., `f x y`. (left-associative)
expr_app = { expr_nlr ~ (sep+ ~ expr_nlr)* }

// right to left composition sequence, e.g., `h . g . f`. (left-associative)
// combinator_dot = _{ "." }
// expr_rtl_comp = { expr_app ~ (seo* ~ combinator_dot ~ sep* ~ expr_app)* } // TODO: will be added later

// left to right composition sequence, e.g., `f >> g >> h`. (left-associative)
// combinator_gtgt = _{ ">>" }
// expr_ltr_comp = { expr_rtl_comp ~ (sep* ~ combinator_gtgt ~ sep* ~ expr_rtl_comp)* } // TODO: will be added later

// left to right application sequence, e.g., `x & f & g`. (left-associative)
combinator_and = _{ "&" }
expr_ltr_app = { expr_app ~ (sep* ~ combinator_and ~ sep* ~ expr_app)* }

// right to left application sequence, e.g., `g $ f $ x`. (right-associative)
combinator_dollar = _{ "$" }
expr_rtl_app = { expr_ltr_app ~ (sep* ~ combinator_dollar ~ sep* ~ expr_ltr_app)* }

expr_type_annotation = { expr_rtl_app ~ (sep* ~ ":" ~ sep* ~ type_expr)? }

expr = { expr_type_annotation }

// === Types ===
type_expr = { type_fun }

type_braced = { "(" ~ sep* ~ type_expr ~ sep* ~ ")" }

type_nlr = { type_tycon | type_var | type_braced }

type_tyapp = { type_nlr ~ (sep+ ~ type_nlr)? }

type_fun = { type_tyapp ~ (sep* ~ "=>" ~ sep* ~ type_expr)? }

type_tycon = { ASCII_ALPHA_UPPER ~ var_char* }

type_var = { !keywords ~ ASCII_ALPHA_LOWER ~ var_char* }

type_qualified = { predicates? ~ sep* ~ type_expr }

predicate = { type_expr ~ sep* ~ ":" ~ sep* ~ trait_name }

predicate_kind = { type_var ~ sep* ~ ":" ~ sep* ~ kind }

predicates = { "[" ~ (sep* ~ (predicate | predicate_kind))* ~ sep* ~ "]" }

predicate_qualified = { predicates? ~ sep* ~ predicate }

// === Kinds ===
kind_star = { "*" }

kind_braced = { "(" ~ sep* ~ kind ~ sep* ~ ")" }

kind_nlr = { kind_star | kind_braced }

kind = { kind_nlr ~ (sep* ~ "->" ~ sep* ~ kind_nlr)* }

// === Type declarations ===
type_name = { ASCII_ALPHA_UPPER ~ var_char* }

type_field_name = { !keywords ~ ASCII_ALPHA_LOWER ~ var_char* }

type_field = { type_field_name ~ sep* ~ ":" ~ sep* ~ type_expr }

type_decl = { "type" ~ sep+ ~ type_name ~ sep* ~ "=" ~ sep* ~  "(" ~ sep* ~ type_field ~ ( sep* ~ "," ~ sep* ~ type_field )* ~ sep* ~ ")" ~ sep* ~ ";" }

// === Trait definitions ===
trait_name = { ASCII_ALPHA_UPPER ~ var_char* }

trait_defn = { "trait" ~ sep+ ~ type_var ~ sep* ~ ":" ~ sep* ~ trait_name ~ sep* ~ "{" ~ (sep* ~ trait_member_defn)* ~ sep* ~ "}" }

trait_member_defn = { trait_member_name ~ sep* ~ ":" ~ sep* ~ type_qualified ~ sep* ~ ";" }

trait_member_name = _{ var }

// === Trait implementations ===
trait_impl = { "impl" ~ sep+ ~ predicate_qualified ~ sep* ~ "{" ~ (sep* ~ trait_member_impl)* ~ sep* ~ "}" }

trait_member_impl = { trait_member_name ~ sep* ~ "=" ~ sep* ~ expr ~ sep* ~ ";" }

// === Global symbols === 
global_symbol_type_defn = { var ~ sep* ~ ":" ~ sep* ~ type_qualified ~ sep* ~ ";" }

global_symbol_defn = { var ~ sep* ~ "=" ~ sep* ~ expr ~ sep* ~ ";" }

// === Module ===
module_name = { ASCII_ALPHA_UPPER ~ var_char* }

module_decl = { "module" ~ sep+ ~ module_name ~ sep* ~ ";" }

toplevel_defns = _{ type_decl | global_symbol_type_defn | global_symbol_defn | trait_defn | trait_impl }

module = { module_decl ~ (sep* ~ toplevel_defns)* }

// === Comments ===
block_comment = _{ "{-"  ~ block_commented_character*  ~ "-}" }

block_commented_character = _{ !"-}" ~ ANY }

line_comment = _{"--" ~ line_commented_character* ~ ( NEWLINE | EOI )}

line_commented_character = _{ !(NEWLINE | EOI) ~ ANY }

// === File ===
file = _{ SOI ~ sep* ~ module ~ sep* ~ EOI }