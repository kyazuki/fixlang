// === Basic rules ===
sep = _{ " " | "\t" | NEWLINE | block_comment | line_comment }

expr_int_lit = { "-"? ~ ASCII_DIGIT ~ ASCII_DIGIT* }

expr_bool_lit = { "true" | "false" }

expr_lit = { expr_int_lit | expr_bool_lit }

keywords = _{ "let" | "in" | "if" | "then" | "else" | "for" | expr_bool_lit }

in_of_let = { "in" | ";" }

eq_of_let = { "=" }

arrow_of_lam = { "->" }

var_char = _{ ASCII_ALPHA | ASCII_DIGIT }

var = { !keywords ~ (ASCII_ALPHA_LOWER ~ var_char* ~ "!"? ) }

// var_typed = { var ~ sep* ~ ":" ~ sep* ~ type_expr }

// === Expressions ===

expr_let = { "let" ~ sep+ ~ var ~ sep* ~ eq_of_let ~ sep* ~ expr ~ sep* ~ in_of_let ~ sep* ~ expr }

expr_if = { "if" ~ sep+ ~ expr ~ sep+ ~ "then" ~ sep+ ~ expr ~ sep+ ~ "else" ~ sep+ ~ expr }

expr_lam = { "\\" ~ sep* ~ var ~ sep*  ~ arrow_of_lam ~ sep* ~ expr }

expr_braced = { "(" ~ sep* ~ expr ~ sep* ~ ")" }

// nlc = non left recursive
expr_nlc = { expr_lit | var | expr_let | expr_if | expr_lam | expr_braced }

expr_app_seq = { expr_nlc ~ (sep+ ~ expr_nlc)* }

expr = { expr_app_seq }

// === Types ===
type_expr = { type_fun | type_except_fun }

type_braced = { "(" ~ sep* ~ type_expr ~ sep* ~ ")" }

type_except_fun = { type_var | type_tycon_app | type_lit | type_braced }
// type_tycon_app has to precede to type_lit

type_var = { !keywords ~ ASCII_ALPHA_LOWER ~ var_char* }

type_lit = { ASCII_ALPHA_UPPER ~ var_char* }

type_tycon_app = { tycon ~ sep* ~ "<" ~ sep* ~ type_expr ~ ("," ~ sep* ~ type_expr)* ~ sep* ~ ">" }

type_fun = { type_except_fun ~ sep* ~ "=>" ~ sep* ~ type_expr }

tycon = { ASCII_ALPHA_UPPER ~ var_char* }

// === Comments ===
block_comment = _{ "{-"  ~ block_commented_character*  ~ "-}" }

block_commented_character = _{ !"-}" ~ ANY }

line_comment = _{"--" ~ line_commented_character* ~ ( NEWLINE | EOI )}

line_commented_character = _{ !(NEWLINE | EOI) ~ ANY }

// === File ===
file = _{ SOI ~ sep* ~ expr ~ sep* ~ EOI }