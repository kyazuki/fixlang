// === Basic rules ===
sep = _{ " " | "\t" | NEWLINE | block_comment | line_comment }

expr_int_lit = { "-"? ~ ASCII_DIGIT ~ ASCII_DIGIT* }

expr_bool_lit = { "true" | "false" }

expr_lit = { expr_int_lit | expr_bool_lit }

keywords = _{ "let" | "in" | "if" | "then" | "else" | "for" | expr_bool_lit | "type" | "struct" }

in_of_let = { "in" | ";" }

eq_of_let = { "=" }

arrow_of_lam = { "->" }

var_char = _{ ASCII_ALPHA | ASCII_DIGIT }

var = { !keywords ~ (ASCII_ALPHA_LOWER ~ var_char* ~ "!"? ) }

// var_typed = { var ~ sep* ~ ":" ~ sep* ~ type_expr }

// === Expressions ===

expr_let = { "let" ~ sep+ ~ var ~ sep* ~ eq_of_let ~ sep* ~ expr ~ sep* ~ in_of_let ~ sep* ~ expr }

expr_if = { "if" ~ sep+ ~ expr ~ sep+ ~ "then" ~ sep+ ~ expr ~ sep+ ~ "else" ~ sep+ ~ expr }

expr_lam = { "\\" ~ sep* ~ var ~ sep*  ~ arrow_of_lam ~ sep* ~ expr }

expr_braced = { "(" ~ sep* ~ expr ~ sep* ~ ")" }

// nlr = non left recursive
expr_nlr = { expr_lit | var | expr_let | expr_if | expr_lam | expr_braced }

// application sequence, e.g., `f x y`. (left-associative)
expr_app = { expr_nlr ~ (sep+ ~ expr_nlr)* }

// right to left composition sequence, e.g., `h . g . f`. (left-associative)
// combinator_dot = _{ "." }
// expr_rtl_comp = { expr_app ~ (seo* ~ combinator_dot ~ sep* ~ expr_app)* } // TODO: will be added later

// left to right composition sequence, e.g., `f >> g >> h`. (left-associative)
// combinator_gtgt = _{ ">>" }
// expr_ltr_comp = { expr_rtl_comp ~ (sep* ~ combinator_gtgt ~ sep* ~ expr_rtl_comp)* } // TODO: will be added later

// left to right application sequence, e.g., `x & f & g`. (left-associative)
combinator_and = _{ "&" }
expr_ltr_app = { expr_app ~ (sep* ~ combinator_and ~ sep* ~ expr_app)* }

// right to left application sequence, e.g., `g $ f $ x`. (right-associative)
combinator_dollar = _{ "$" }
expr_rtl_app = { expr_ltr_app ~ (sep* ~ combinator_dollar ~ sep* ~ expr_ltr_app)* }

expr = { expr_rtl_app }

// === Types ===
type_expr = { type_fun }

type_braced = { "(" ~ sep* ~ type_expr ~ sep* ~ ")" }

type_nlr = { type_tycon | type_braced }

type_tyapp = { type_nlr ~ (sep* ~ "<" ~ sep* ~ type_expr ~ ("," ~ sep* ~ type_expr)* ~ sep* ~ ">")? }

type_fun = { type_tyapp ~ sep* ~ "=>" ~ sep* ~ type_expr }

type_tycon = { ASCII_ALPHA_UPPER ~ var_char* }

// === Type declarations ===
type_name = { ASCII_ALPHA_UPPER ~ var_char* }

type_field_name = { !keywords ~ ASCII_ALPHA_LOWER ~ var_char* }

type_field = _{ type_field_name ~ sep* ~ ":" ~ sep* ~ type_expr }

type_decl = { "type" ~ sep+ ~ type_name ~ sep* ~ "=" ~ sep* ~ "struct" ~ sep* ~ "(" ~ sep* ~ type_field ~ ( sep* ~ "," ~ sep* ~ type_field )* ~ sep* ~ ")" ~ sep* ~ ";" }

// === Module ===
module_name = { ASCII_ALPHA_UPPER ~ var_char* }

module_decl = { "module" ~ sep+ ~ module_name ~ sep* ~ ";" }

module = { module_decl ~ (sep* ~ type_decl)* ~ sep* ~ expr }

// === Comments ===
block_comment = _{ "{-"  ~ block_commented_character*  ~ "-}" }

block_commented_character = _{ !"-}" ~ ANY }

line_comment = _{"--" ~ line_commented_character* ~ ( NEWLINE | EOI )}

line_commented_character = _{ !(NEWLINE | EOI) ~ ANY }

// === File ===
file = _{ SOI ~ sep* ~ module ~ sep* ~ EOI }