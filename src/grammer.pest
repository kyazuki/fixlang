// === Basic rules ===
sep = _{ " " | "\t" | NEWLINE | block_comment | line_comment }

keywords = _{ ("let" | "in" | "if" | "then" | "else" | "for" | "true" | "false" | "type" | "trait" | "impl" | "struct" | "union") ~ sep+ }

in_of_let = { "in" | ";" }

eq_of_let = { "=" }

arrow_of_lam = { "->" }

var_char = _{ ASCII_ALPHA | ASCII_DIGIT | "_" }

name_head_small = _{ ASCII_ALPHA_LOWER | "_" }

name_head_large = _{ ASCII_ALPHA_UPPER }

var = { !keywords ~ (name_head_small ~ var_char* ~ "!"? ) }

var_with_type = { var ~ (sep* ~ ":" ~ sep* ~ type_expr)? }

// === Expressions ===

namespace_item = { name_head_large ~ var_char* }

namespace = { (namespace_item ~ ".")* }

expr_int_lit = { "-"? ~ ASCII_DIGIT ~ ASCII_DIGIT* }

expr_bool_lit = { "true" | "false" }

expr_lit = { expr_int_lit | expr_bool_lit }

expr_var = { namespace ~ var }

expr_let = { "let" ~ sep+ ~ var_with_type ~ sep* ~ eq_of_let ~ sep* ~ expr ~ sep* ~ in_of_let ~ sep* ~ expr }

expr_if = { "if" ~ sep+ ~ expr ~ sep+ ~ "then" ~ sep+ ~ expr ~ sep+ ~ "else" ~ sep+ ~ expr }

expr_lam = { "\\" ~ sep* ~ var ~ sep*  ~ arrow_of_lam ~ sep* ~ expr }

expr_braced = { "(" ~ sep* ~ expr ~ sep* ~ ")" }

// nlr = non left recursive
expr_nlr = { expr_lit | expr_var | expr_let | expr_if | expr_lam | expr_braced }

// application sequence, e.g., `f x y`. (left-associative)
expr_app = { expr_nlr ~ (sep+ ~ expr_nlr)* }

// TODO: two composition operator "<<" and ">>"" will be added.

// right to left application sequence, e.g., `g $ f $ x`. (right-associative)
combinator_dollar = _{ "$" }
expr_rtl_app = { expr_app ~ (sep* ~ combinator_dollar ~ sep* ~ expr_app)* }

// left to right application sequence, e.g., `x . f . g`. (left-associative)
combinator_dot = _{ "." }
expr_ltr_app = { expr_rtl_app ~ (sep* ~ combinator_dot ~ sep* ~ expr_rtl_app)* }

// unary operator-
// NOTE: we should write this rule so that "-1" is parsed as expr_int_lit.
operator_minus = { "-" }
expr_neg = { expr_ltr_app | operator_minus? ~ expr_ltr_app }

// operator*,/,% (left-associative)
operator_mul = { "*" | "/" | "%" }
expr_mul = { expr_neg ~ (sep* ~ operator_mul ~ sep* ~ expr_neg)? }

// operator+/- (left-associative)
operator_plus = { "+" | "-" }
expr_plus = { expr_mul ~ (sep* ~ operator_plus ~ sep* ~ expr_mul)? }

// operator==
combinator_eq = _{ "==" }
expr_eq = { expr_plus ~ (sep* ~ combinator_eq ~ sep* ~ expr_plus)? }

expr_type_annotation = { expr_eq ~ (sep* ~ ":" ~ sep* ~ type_expr)? }

expr = { expr_type_annotation }

// === Types ===
type_expr = { type_fun }

type_braced = { "(" ~ sep* ~ type_expr ~ sep* ~ ")" }

type_nlr = { type_tycon | type_var | type_braced }

type_tyapp = { type_nlr ~ (sep+ ~ type_nlr)* }

type_fun = { type_tyapp ~ (sep* ~ "->" ~ sep* ~ type_expr)? }

type_tycon = { name_head_large ~ var_char* }

type_var = { !keywords ~ name_head_small ~ var_char* }

type_qualified = { predicates? ~ sep* ~ type_expr }

predicate = { type_expr ~ sep* ~ ":" ~ sep* ~ trait_name }

predicate_kind = { type_var ~ sep* ~ ":" ~ sep* ~ kind }

predicates = { "[" ~ (sep* ~ (predicate | predicate_kind))* ~ sep* ~ "]" }

predicate_qualified = { predicates? ~ sep* ~ predicate }

// === Kinds ===
kind_star = { "*" }

kind_braced = { "(" ~ sep* ~ kind ~ sep* ~ ")" }

kind_nlr = { kind_star | kind_braced }

kind = { kind_nlr ~ (sep* ~ "->" ~ sep* ~ kind_nlr)* }

// === Type declarations ===
type_name = { name_head_large ~ var_char* }

type_field_name = { !keywords ~ name_head_small ~ var_char* }

type_field = { type_field_name ~ sep* ~ ":" ~ sep* ~ type_expr }

type_decl = { "type" ~ sep+ ~ type_name ~ (sep+ ~ type_var)* ~ sep* ~ "=" ~ sep* ~ (struct_defn | union_defn) ~ sep* ~ ";" }

comma_separated_type_fields = _{ type_field ~ ( sep* ~ "," ~ sep* ~ type_field )* }

// === struct definitions ===
struct_defn = { "struct" ~ sep* ~ "(" ~ sep* ~ comma_separated_type_fields ~ sep* ~ ")" }

// === union definitions ===
union_defn = { "union" ~ sep* ~ "(" ~ sep* ~ comma_separated_type_fields ~ sep* ~ ")" }

// === Trait definitions ===
trait_name = { name_head_large ~ var_char* }

trait_defn = { "trait" ~ sep+ ~ predicates? ~ sep* ~ type_var ~ sep* ~ ":" ~ sep* ~ trait_name ~ sep* ~ "{" ~ (sep* ~ trait_member_defn)* ~ sep* ~ "}" }

trait_member_defn = { trait_member_name ~ sep* ~ ":" ~ sep* ~ type_qualified ~ sep* ~ ";" }

trait_member_name = _{ var }

// === Trait implementations ===
trait_impl = { "impl" ~ sep+ ~ predicate_qualified ~ sep* ~ "{" ~ (sep* ~ trait_member_impl)* ~ sep* ~ "}" }

trait_member_impl = { trait_member_name ~ sep* ~ "=" ~ sep* ~ expr ~ sep* ~ ";" }

// === Global symbols === 
global_symbol_type_defn = { var ~ sep* ~ ":" ~ sep* ~ type_qualified ~ sep* ~ ";" }

global_symbol_defn = { var ~ sep* ~ "=" ~ sep* ~ expr ~ sep* ~ ";" }

// === Module ===
module_name = { name_head_large ~ var_char* }

module_decl = { "module" ~ sep+ ~ module_name ~ sep* ~ ";" }

toplevel_defns = _{ type_decl | global_symbol_type_defn | global_symbol_defn | trait_defn | trait_impl }

module = { module_decl ~ (sep* ~ toplevel_defns)* }

// === Comments ===
block_comment = _{ "/*"  ~ block_commented_character*  ~ "*/" }

block_commented_character = _{ !"*/" ~ ANY }

line_comment = _{"//" ~ line_commented_character* ~ ( NEWLINE | EOI )}

line_commented_character = _{ !(NEWLINE | EOI) ~ ANY }

// === File ===
file = _{ SOI ~ sep* ~ module ~ sep* ~ EOI }