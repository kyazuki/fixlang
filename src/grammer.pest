// === Basic rules ===
sep = _{ " " | "\t" | NEWLINE | block_comment | line_comment }

keywords = _{ ("let" | "in" | "if" | "then" | "else" | "for" | "true" | "false" | "type" | "trait" | "impl" | "struct" | "union") ~ sep+ }

in_of_let = { "in" | ";" }

eq_of_let = { "=" }

var_char = _{ ASCII_ALPHA | ASCII_DIGIT | "_" }

name_head_small = _{ ASCII_ALPHA_LOWER | "_" }

name_head_large = _{ ASCII_ALPHA_UPPER }

var = { !keywords ~ (name_head_small ~ var_char* ~ "!"? ) }

// === Expressions ===

namespace_item = { name_head_large ~ var_char* }

namespace = { namespace_item ~ ("." ~ namespace_item)* }

expr_int_lit = { "-"? ~ ASCII_DIGIT ~ ASCII_DIGIT* }

expr_bool_lit = { "true" | "false" }

expr_string_lit = { "\"" ~ string_lit_inner ~ "\"" }

string_lit_inner = { string_char* }

string_char = {
    !("\"" | "\\") ~ ANY 
    | "\\" ~ ("\"" | "\\" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

expr_lit = { expr_int_lit | expr_bool_lit | expr_string_lit }

expr_var = { (namespace ~ ".")? ~ var }

expr_let = { "let" ~ sep+ ~ pattern ~ sep* ~ eq_of_let ~ sep* ~ expr ~ sep* ~ in_of_let ~ sep* ~ expr }

expr_if = { "if" ~ sep+ ~ expr ~ sep+ ~ "then" ~ sep+ ~ expr ~ sep+ ~ "else" ~ sep+ ~ expr }

expr_lam = { "|" ~ sep* ~ pattern ~ (sep* ~ "," ~ sep* ~ pattern)* ~ sep* ~ "|" ~ sep* ~ expr }

// For n = 0 or n >= 2 this is interpreted as tuple, and for n = 1 this is treated as braced type.
expr_tuple = { "(" ~ (sep* ~ expr ~ (sep* ~ "," ~ sep* ~ expr)*)? ~ sep* ~ ")" }

// nlr = non left recursive
expr_nlr = { expr_lit | expr_var | expr_let | expr_if | expr_lam | expr_tuple }

// List of arguments. Can be an empty list.
arg_list = { "(" ~ sep* ~ ")" | "(" ~ sep* ~ expr ~ (sep* ~ "," ~ sep* ~ expr)* ~ sep* ~ ")" }

// application sequence, e.g., `f(x,y)`. (left-associative)
expr_app = { expr_nlr ~ (sep* ~ arg_list)? }

// TODO: two composition operators "<<" and ">>"" will be added.

// left to right application sequence, e.g., `x . f . g`. (left-associative)
combinator_dot = _{ "." }
expr_ltr_app = { expr_app ~ (sep* ~ combinator_dot ~ sep* ~ expr_app)* }

// unary operators
// NOTE: we should write this rule so that "-1" is parsed as expr_int_lit.
operator_unary = { "-" | "!" }
expr_unary = { expr_ltr_app | operator_unary+ ~ expr_ltr_app }

// operator*,/,% (left-associative)
operator_mul = { "*" | "/" | "%" }
expr_mul = { expr_unary ~ (sep* ~ operator_mul ~ sep* ~ expr_unary)* }

// operator+/- (left-associative)
operator_plus = { "+" | "-" }
expr_plus = { expr_mul ~ (sep* ~ operator_plus ~ sep* ~ expr_mul)* }

// comparison operators
// NOTE: "<=" and ">=" has to put in from of "<" and ">".
operator_cmp = { "==" | "!=" | "<=" | ">=" | "<" | ">" }
expr_cmp = { expr_plus ~ (sep* ~ operator_cmp ~ sep* ~ expr_plus)? }

// operator && (left-associative)
operator_and = { "&&" }
expr_and = { expr_cmp ~ (sep* ~ operator_and ~ sep* ~ expr_cmp)* }

// operator && (left-associative)
operator_or = { "||" }
expr_or = { expr_and ~ (sep* ~ operator_or ~ sep* ~ expr_and)* }

// right to left application sequence, e.g., `g $ f $ x`. (right-associative)
combinator_dollar = _{ "$" }
expr_rtl_app = { expr_or ~ (sep* ~ combinator_dollar ~ sep* ~ expr_or)* }

expr_type_annotation = { expr_rtl_app ~ (sep* ~ ":" ~ sep* ~ type_expr)? }

expr = { expr_type_annotation }

// === Patterns === 

pattern = { pattern_var | pattern_tuple | pattern_struct | pattern_union }

pattern_var = { var ~ (sep* ~ ":" ~ sep* ~ type_expr)? }

pattern_tuple = { "(" ~ sep* ~ ")" | "(" ~ sep* ~ pattern ~ (sep* ~ "," ~ sep* ~ pattern)+ ~ ")" }

pattern_struct = { type_tycon ~ sep* ~ "{" ~ sep* ~ type_field_name ~ sep* ~ ":" ~ sep* ~ pattern ~ (sep* ~ "," ~ sep* ~ type_field_name ~ sep* ~ ":" ~ sep* ~ pattern)* ~ sep* ~ "}" }

pattern_union = { type_tycon ~ sep* ~ "." ~ sep* ~ type_field_name ~ sep* ~ "(" ~ sep* ~ pattern ~ sep* ~ ")" }

// === Types ===
type_expr = { type_fun }

// For n = 0 or n >= 2 this is interpreted as tuple, and for n = 1 this is treated as braced type.
type_tuple = { "(" ~ (sep* ~ type_expr ~ (sep* ~ "," ~ sep* ~ type_expr)*)? ~ sep* ~ ")" }

type_nlr = { type_tycon | type_var | type_tuple }

type_tyapp = { type_nlr ~ (sep+ ~ type_nlr)* }

type_fun = { type_tyapp ~ (sep* ~ "->" ~ sep* ~ type_expr)? }

type_tycon = { name_head_large ~ var_char* }

type_var = { !keywords ~ name_head_small ~ var_char* }

type_qualified = { predicates? ~ sep* ~ type_expr }

predicate = { type_expr ~ sep* ~ ":" ~ sep* ~ trait_name }

predicate_kind = { type_var ~ sep* ~ ":" ~ sep* ~ kind }

predicates = { "[" ~ sep* ~ (predicate | predicate_kind) ~ (sep* ~ "," ~ sep* ~ (predicate | predicate_kind))* ~ sep* ~ "]" }

predicate_qualified = { predicates? ~ sep* ~ predicate }

// === Kinds ===
kind_star = { "*" }

kind_braced = { "(" ~ sep* ~ kind ~ sep* ~ ")" }

kind_nlr = { kind_star | kind_braced }

kind = { kind_nlr ~ (sep* ~ "->" ~ sep* ~ kind_nlr)* }

// === Type definitions ===
type_name = { name_head_large ~ var_char* }

type_field_name = { !keywords ~ name_head_small ~ var_char* }

type_field = { type_field_name ~ sep* ~ ":" ~ sep* ~ type_expr }

type_defn = { "type" ~ sep+ ~ type_name ~ (sep+ ~ type_var)* ~ sep* ~ "=" ~ sep* ~ (struct_defn | union_defn) ~ sep* ~ ";" }

comma_separated_type_fields = _{ type_field ~ ( sep* ~ "," ~ sep* ~ type_field )* }

box_or_unbox = { "box" | "unbox" }

// === struct definitions ===
struct_defn = { (box_or_unbox ~ sep*)? ~ "struct" ~ sep* ~ "(" ~ sep* ~ comma_separated_type_fields ~ sep* ~ ")" }

// === union definitions ===
union_defn = { (box_or_unbox ~ sep*)? ~ "union" ~ sep* ~ "(" ~ sep* ~ comma_separated_type_fields ~ sep* ~ ")" }

// === Trait definitions ===
trait_name = { name_head_large ~ var_char* }

trait_defn = { "trait" ~ sep+ ~ predicates? ~ sep* ~ type_var ~ sep* ~ ":" ~ sep* ~ trait_name ~ sep* ~ "{" ~ (sep* ~ trait_member_defn)* ~ sep* ~ "}" }

trait_member_defn = { trait_member_name ~ sep* ~ ":" ~ sep* ~ type_qualified ~ sep* ~ ";" }

trait_member_name = _{ var }

// === Trait implementations ===
trait_impl = { "impl" ~ sep+ ~ predicate_qualified ~ sep* ~ "{" ~ (sep* ~ trait_member_impl)* ~ sep* ~ "}" }

trait_member_impl = { trait_member_name ~ sep* ~ "=" ~ sep* ~ expr ~ sep* ~ ";" }

// === Global names === 
global_name_type_sign = { var ~ sep* ~ ":" ~ sep* ~ type_qualified ~ sep* ~ ";" }

global_name_defn = { var ~ sep* ~ "=" ~ sep* ~ expr ~ sep* ~ ";" }

// === Module ===
module_name = { name_head_large ~ var_char* }

module_defn = { "module" ~ sep+ ~ namespace ~ sep* ~ ";" }

global_defns = { global_defns_in_namespace | type_defn | global_name_type_sign | global_name_defn | trait_defn }

global_defns_in_namespace = { "namespace" ~ sep+ ~ namespace ~ sep* ~ "{" ~ (sep* ~ global_defns)* ~ sep* ~ "}" }

module = { module_defn ~ (sep* ~ (global_defns | trait_impl))* }

// === Comments ===
block_comment = _{ "/*"  ~ block_commented_character*  ~ "*/" }

block_commented_character = _{ !"*/" ~ ANY }

line_comment = _{"//" ~ line_commented_character* ~ ( NEWLINE | EOI )}

line_commented_character = _{ !(NEWLINE | EOI) ~ ANY }

// === File ===
file = _{ SOI ~ sep* ~ module ~ sep* ~ EOI }