module Math;

import Debug;

// Calculate arc cosine of the argument.
// This is wrapper of C's acos.
acos : F64 -> F64;
acos = |x| CALL_C[F64 acos(F64), x];

// Calculate arc sine of the argument.
// This is wrapper of C's asin.
asin : F64 -> F64;
asin = |x| CALL_C[F64 asin(F64), x];

// Calculate arc tangent of the argument.
// This is wrapper of C's atan.
atan : F64 -> F64;
atan = |x| CALL_C[F64 atan(F64), x];

// Calculate arc tangent of y/x for argument x, y.
// This is wrapper of C's atan2.
atan2 : F64 -> F64 -> F64;
atan2 = |x, y| CALL_C[F64 atan(F64, F64), x, y];

// Calculate the smallest integral value not less than the argument.
// This is wrapper of C's ceil.
ceil : F64 -> F64;
ceil = |x| CALL_C[F64 ceil(F64, F64), x];

// Calculate the cosine of the argument.
// This is wrapper of C's cos.
cos : F64 -> F64;
cos = |x| CALL_C[F64 cos(F64), x];

// Calculate the hyperbolic cosine of the argument.
// This is wrapper of C's cosh.
cosh : F64 -> F64;
cosh = |x| CALL_C[F64 cosh(F64), x];

// Calculate the natural exponential of the argument.
// This is wrapper of C's exp.
exp : F64 -> F64;
exp = |x| CALL_C[F64 exp(F64), x];

// Calculate the largest integral value not greater than the argument.
// This is wrapper of C's floor.
floor : F64 -> F64;
floor = |x| CALL_C[F64 floor(F64), x];

// Calculate the floating point remainder of division. 
// Note that `x.fmod(y)` calculates the remainder of dividing x by y.
// This is wrapper of C's fmod, swapped the arguments.
fmod : F64 -> F64;
fmod = |y, x| CALL_C[F64 fmod(F64, F64), x, y];

// Calculate table (2-dimensional array) of binomial coefficients.
// `binomial_coefficients(m)` evaluates to an array of arrays `table` where `table.@(n).@(r)` is the binomial coefficient "binom(n, r)" for 0 <= n <= m and 0 <= r <= n.
// Here `m` has to be less than or equal to 66 to avoid overflow.
binomial_coefficients : I64 -> Array (Array I64);
binomial_coefficients = |m| (
    let _ = assert(|_|"[binomial_coefficients] The argument must be non-negative and less than or equal to 66.", 0 <= m && m <= 66);
    let size = m + 1;
    let arr = Iterator::range(0, size).fold(Array::empty(size), |arr, n| arr.push_back!(Array::fill(n+1, 0)));
    let arr = arr.(mod!(0) $ set!(0) $ 1);
    Iterator::range(1, size).fold(arr, |arr, n| (
        Iterator::range(0, n+1).fold(arr, |arr, r| (
            let x = if 0 <= r-1 && r-1 <= n-1 { arr.@(n-1).@(r-1) } else { 0 };
            let y = if 0 <= r && r <= n-1 { arr.@(n-1).@(r) } else { 0 };
            arr.(mod!(n) $ set!(r) $ x + y)
        ))
    ))
);

// Calculate greatest common divisor of two non-negative integers. 
_gcd_nonneg : I64 -> I64 -> I64;
_gcd_nonneg = |n, m| (
    if n > m { _gcd_nonneg(m, n) };
    // n <= m
    if n == 0 { m };
    _gcd_nonneg(m % n, n)
);

// Calculate greatest common divisor of two integers.
// NOTE: currently, this function does not support I64::minimum.
gcd : I64 -> I64 -> I64;
gcd = |n, m| _gcd_nonneg(n.abs, m.abs);

// pi as F32
pi32 : F32;
pi32 = 3.14159265_F32;

// pi as F64
pi64 : F64;
pi64 = 3.141592653589793;