module Std;

namespace Array {

    // Sort elements in a range of a vector by "less than" comparator.
    // This function receives a working buffer as the first argument to reduce memory allocation, and returns it as second element.
    _sort_range_using_buffer : Array a -> I64 -> I64 -> ((a, a) -> Bool) -> Array a -> (Array a, Array a);
    _sort_range_using_buffer = |buffer, begin, end, less_than, vec| (
        // Merge sorting.
        let len = end - begin;
        if len <= 1 { (vec, buffer) };
        // Divide into intervals.
        let former_len = len / 2;
        let former_begin = begin;
        let former_end = begin + former_len;
        let latter_len = len - former_len;
        let latter_begin = former_end;
        let latter_end = end;
        let (vec, buffer) = vec._sort_range_using_buffer(buffer, former_begin, former_end, less_than);
        let (vec, buffer) = vec._sort_range_using_buffer(buffer, latter_begin, latter_end, less_than);
        // Merge former and latter to buffer.
        let buffer = buffer.reduce_length(0);
        let former_pos = former_begin;
        let latter_pos = latter_begin;
        let buffer = loop((former_pos, latter_pos, buffer), |(former_pos, latter_pos, buffer)|(
            if former_pos == former_end { // If former_pos reached to the end,
                if latter_pos == latter_end { break $ buffer };
                // Copy elements in latter to buffer.
                let buffer = buffer.push_back(vec.get(latter_pos));
                continue $ (former_pos, latter_pos + 1, buffer)
            };
            if latter_pos == latter_end { // If latter_pos reached to the end,
                // Copy elements in former to buffer.
                let buffer = buffer.push_back(vec.get(former_pos));
                continue $ (former_pos + 1, latter_pos, buffer)
            };
            let former_elem = vec.get(former_pos);
            let latter_elem = vec.get(latter_pos);
            if less_than((former_elem, latter_elem)) {
                // Copy elements in former to buffer.
                let buffer = buffer.push_back(former_elem);
                continue $ (former_pos + 1, latter_pos, buffer)
            } else {
                // Copy elements in latter to buffer.
                let buffer = buffer.push_back(latter_elem);
                continue $ (former_pos, latter_pos + 1, buffer)
            }
        ));
        // Copy buffer to vec.
        loop((0, vec), |(idx, vec)|(
            if idx == len { break $ (vec, buffer) };
            let vec = vec.set(begin + idx, buffer.get(idx));
            continue $ (idx + 1, vec)
        ))
    );

    // Append an array to an array.
    // Note: Since `a1.append(a2)` puts `a2` after `a1`, `append(lhs, rhs)` puts `lhs` after `rhs`.
    append : Array a -> Array a -> Array a;
    append = |v2, v1| (
        // if v2 is empty, return early to avoid unnecessary clone.
        let v2_len = v2.get_size;
        if v2_len == 0 { v1 };

        // if v1 is empty, return early to avoid unnecessary clone.
        let v1_len = v1.get_size;
        if v1_len == 0 { v2 };

        // Reserve v1's buffer and force uniqueness.
        let len = v1_len + v2_len;
        let v1 = v1.reserve(len).force_unique;
        
        // Set length.
        let v1 = v1.__unsafe_set_length(len);

        // Copy elements of v2 to v1.
        loop((0, v1), |(idx, v1)|(
            if idx >= v2_len { break $ v1 };
            let v1 = v1.__unsafe_set(v1_len + idx, v2.get(idx));
            continue $ (idx+1, v1)
        ))
    );

    // Call a function with a pointer to the memory region where elements are stored.
    borrow_ptr : (Ptr -> b) -> Array a -> b;
    borrow_ptr = |f, arr| (
        let res = f(arr._get_ptr);
        let _ = arr; // Use array after calling f
        res
    );

    // Find the first index at which the element satisfies a condition.
    find_by : (a -> Bool) -> Array a -> Option I64;
    find_by = |cond, arr| (
        let len = arr.get_size;
        loop(0, |idx| (
            if idx == len { break $ Option::none $ () };
            if cond(arr.get(idx)) { break $ Option::some $ idx };
            continue $ idx + 1
        ))
    );

    // Create an array from an iterator.
    from_iter : Iterator a -> Array a;
    from_iter = |iter| (
        let len = iter.get_size;
        let arr = Array::empty(len).__unsafe_set_length(len);
        iter.fold((arr, 0), |(arr, idx), elem| (
            let arr = arr.__unsafe_set(idx, elem);
            (arr, idx+1)
        )).@0
    );

    // Creates an array by a mapping function.
    from_map : I64 -> (I64 -> a) -> Array a;
    from_map = |size, map| (
        let arr = Array::empty(size).__unsafe_set_length(size);
        loop((0, arr), |(idx, arr)|(
            if idx == size {
                break $ arr
            } else {
                let arr = arr.__unsafe_set(idx, map(idx));
                continue $ (idx + 1, arr)
            }
        ))
    );

    // Get the first element of an array. Returns none if the array is empty.
    get_first : Array a -> Option a;
    get_first = |arr| (
        if arr.is_empty { Option::none() };
        Option::some $ arr.get(0)
    );

    // Get the last element of an array. Returns none if the array is empty.
    get_last : Array a -> Option a;
    get_last = |arr| (
        let len = arr.get_size;
        if len == 0 { Option::none() };
        Option::some $ arr.get(len - 1)
    );

    // Returns if the array is empty
    is_empty : Array a -> Bool;
    is_empty = |arr| ( arr.get_size == 0 );

    // Pop an element at the back of an array.
    // If the array is empty, this function does nothing.
    pop_back : Array a -> Array a;
    pop_back = |arr| (
        let len = arr.get_size;
        if len == 0 { arr };
        let arr = arr.force_unique;
        let released_elem = arr.__unsafe_get(len-1);
        arr.__unsafe_set_length(len-1)
    );

    // Push an element to the back of an array.
    push_back : a -> Array a -> Array a;
    push_back = |e, arr| (
        let len = arr.get_size;
        let arr = if arr.get_capacity < len + 1 {
            arr.reserve(2*(len + 1))
        } else {
            arr
        };
        let arr = arr.force_unique.__unsafe_set_length(len+1);
        arr.__unsafe_set(len, e)
    );

    // Reduce the length of an array.
    reduce_length : I64 -> Array a -> Array a;
    reduce_length = |length, vec| (
        loop(vec, |vec|(
            if length >= vec.get_size { break $ vec };
            continue $ vec.pop_back
        ))
    );

    // Reserves the memory region for an array.
    // TODO: change to more optimized implementation.
    reserve : I64 -> Array a -> Array a;
    reserve = |cap, arr| (
        if cap <= arr.get_capacity { arr };
        let len = arr.get_size;
        let new = Array::empty(cap).__unsafe_set_length(len);
        loop((0, new), |(idx, new)|(
            if idx == len {
                break $ new
            } else {
                let new = new.__unsafe_set(idx, arr.get(idx));
                continue $ (idx + 1, new)
            }
        ))
    );

    // Sort elements in a vector by "less than" comparator.
    sort_by : ((a, a) -> Bool) -> Array a -> Array a;
    sort_by = |less_than, vec| (
        let buffer = Array::empty(vec.get_size);
        let (vec, buffer) = vec._sort_range_using_buffer(buffer, 0, vec.get_size, less_than);
        vec
    );


    // Convert an array to an iterator.
    to_iter : Array a -> Iterator a;
    to_iter = Iterator::from_array;

}

impl [a : Eq] Array a : Eq {
    // Compare two vectors.
    eq = |lhs, rhs| (
        if lhs.get_size != rhs.get_size { false };
        let len = lhs.get_size;
        loop(0, |idx| (
            if idx == len { break $ true };
            if lhs.get(idx) != rhs.get(idx) { break $ false };
            continue $ idx + 1
        ))
    );
}

impl [a : Hash] Array a : Hash {
    hash = |arr| (
        let len = arr.get_size;
        loop((0, 5381_U64), |(i, h)| (
            if i == len { break $ h };
            let h = h.shift_left(5_U64) + h + arr.get(i).hash;
            continue $ (i+1, h)
        ))
    );
}

impl Bool : ToString {
    to_string = |lhs| (
        if lhs { "true" } else { "false" }
    );
}

namespace Debug {

    assert_eq : [a: Eq] String -> a -> a -> ();
    assert_eq = |msg, lhs, rhs| assert(msg, lhs == rhs);

    assert : String -> Bool -> ();
    assert = |msg, b| (
        if !b {
            let u = debug_println("assertion failed!: ");
            let u = debug_println(msg);
            abort()
        } else {
            ()
        }
    );

    debug_print : String -> ();
    debug_print = |s| (
        s.borrow_c_str(|ptr| (
            let _ = CALL_C[I32 printf(Ptr, ...), ptr];
            let _ = CALL_C[I32 fflush(Ptr), nullptr];
            ()
        ))
    );

    debug_println : String -> ();
    debug_println = |s| (
        let _ = s.borrow_c_str(|ptr| (
            CALL_C[I32 printf(Ptr, ...), ptr]
        ));
        let _ = "\n".borrow_c_str(|ptr| (
            CALL_C[I32 printf(Ptr, ...), ptr]
        ));
        let _ = CALL_C[I32 fflush(Ptr), nullptr];
        ()
    );
}

// `Destructor a` is a boxed type which has two fields of type `a` and `a -> ()`, where the latter field is called destructor.
// The destructor function will be called when a value of `Destructor a` is deallocated.
// Note that the inner value of type `a` may be still alive after the destructor function is called.
// This type is useful to manage resources allocated by C function.
type Destructor a = box struct { value : a, dtor : a -> () };

namespace Destructor {
    // Make a destructor value.
    make : a -> (a -> ()) -> Destructor a;
    make = |val, dtor| Destructor { value : val, dtor : dtor };
}

impl I32 : ToString {
    to_string = I32::_I32_to_string;
}

impl I64 : ToString {
    to_string = I64::_I64_to_string;
}


type HashMap k v = struct { _table : Array (Array (Option (k, v))), _size : I64 };

namespace HashMap {

    // Find the place where an element with a key is stored.
    // Returns pair of (index in hash table, index in bucket).
    _find_place : [k : Eq, k : Hash] k -> HashMap k v -> (I64, Option I64);
    _find_place = |k, mp| (
        let cap = mp.get_capacity;
        if cap == 0 { (-1, Option::none()) };
        let table_idx = (k.hash % cap.to_U64).to_I64;
        let opt_bucket_idx = mp.@_table.get(table_idx).find_by(|opt_kv| opt_kv.is_some && opt_kv.as_some.@0 == k);
        (table_idx, opt_bucket_idx)
    );

    // Get a POT (power-of-two) value which is less than or equal to the given value.
    // This is used for calculating capacity value.
    _get_pot_geq : I64 -> I64;
    _get_pot_geq = |max_size| (
        loop(1, |v| if v >= max_size { break $ v } else { continue $ 2 * v })
    );

    // Create an empty HashMap which is reserved so that it will not rehash until size exceeds the spacified value.
    empty : I64 -> HashMap k v;
    empty = |max_size| (
        let cap = HashMap::_get_pot_geq(max_size);
        HashMap { _table : Array::fill(cap, Array::empty(0)), _size : 0 }
    );

    // Erase an element from a HashMap.
    erase : [k : Eq, k : Hash] k -> HashMap k v -> HashMap k v;
    erase = |k, mp| (
        let (table_idx, opt_bucket_idx) = mp._find_place(k);
        if opt_bucket_idx.is_some {
            let bucket_idx = opt_bucket_idx.as_some;
            let mp = mp.mod__table(Array::mod(table_idx, Array::set(bucket_idx, Option::none())));
            mp.mod__size(Add::add(-1))
        } else {
            mp
        }
    );

    // Find an element from a HashMap.
    find : [k : Eq, k : Hash] k -> HashMap k v -> Option v;
    find = |k, mp| (
        let (table_idx, opt_bucket_idx) = mp._find_place(k);
        if opt_bucket_idx.is_none {
            Option::none()
        } else {
            let bucket_idx = opt_bucket_idx.as_some;
            let v = mp.@_table.get(table_idx).get(bucket_idx).as_some.@1;
            Option::some(v)
        }
    );
    
    // Find an element from a HashMap. If the map doesn't contain the key, it returns the given default value.
    find_or : [k : Eq, k : Hash] k -> v -> HashMap k v -> v;
    find_or = |key, def, mp| mp.find(key).as_some_or(def);

    // Get capacity of a HashMap. 
    get_capacity : HashMap k v -> I64;
    get_capacity = |mp| mp.@_table.get_size;

    // Get size (number of elements) in a HashMap.
    get_size : HashMap k v -> I64;
    get_size = |mp| mp.@_size;

    // Insert an element into a HashMap.
    insert : [k : Eq, k : Hash] k -> v -> HashMap k v -> HashMap k v;
    insert = |k, v, mp| (
        let size = mp.get_size;
        let cap = mp.get_capacity;
        let mp = if size < cap { mp } else { mp.reserve(size+1) };
        let (table_idx, opt_bucket_idx) = mp._find_place(k);
        if opt_bucket_idx.is_some {
            let bucket_idx = opt_bucket_idx.as_some;
            mp.mod__table(Array::mod(table_idx, Array::set(bucket_idx, Option::some $ (k, v))))
        } else {
            let open_idx = mp.@_table.get(table_idx).find_by(Option::is_none);
            let mp = if open_idx.is_some {
                let open_idx = open_idx.as_some;
                mp.mod__table(Array::mod(table_idx, Array::set(open_idx, Option::some $ (k, v))))
            } else {
                mp.mod__table(Array::mod(table_idx, Array::push_back(Option::some $ (k, v))))
            };
            mp.mod__size(Add::add(1))
        }
    );

    // Reserve a HashMap so that it will not rehash until size exceeds the spacified value.
    reserve : [k : Hash, k : Eq] I64 -> HashMap k v -> HashMap k v;
    reserve = |max_size, mp| (
        if max_size <= mp.get_capacity { mp };
        let new_mp = HashMap::empty(max_size);
        mp.to_iter.fold(new_mp, |new_mp, (k, v)| new_mp.insert(k, v))
    );

    // Convert a HashMap into an iterator.
    to_iter : HashMap k v -> Iterator (k, v);
    to_iter = |mp| (
        let table_idx = *Iterator::range(0, mp.get_capacity);
        let bucket_idx = *Iterator::range(0, mp.@_table.get(table_idx).get_size);
        let opt_elem = mp.@_table.get(table_idx).get(bucket_idx);
        if opt_elem.is_none { Iterator::empty };
        pure $ opt_elem.as_some
    );
}

type IO a = unbox struct { _data : () -> a };

namespace IO {
    // Perform the I/O action. This may violate purity of Fix.
    __unsafe_perform : IO a -> a;
    __unsafe_perform = |io| (io.@_data)();

    // Close a file.
    close_file : IOHandle -> IO ();
    close_file = |handle| (
        IO { _data : |_|(
            let _ = CALL_C[I32 fclose(Ptr), handle.@_file_ptr];
            ()
        ) }
    );

    // Open a file. The second argument is a mode string for `fopen` C function. 
    open_file : Path -> String -> IOResult IOError IOHandle;
    open_file = |path, mode| (
        IOResult { _data  : IO { _data : |_|(
            let path_str = path.to_string;
            let res = path_str.borrow_c_str(|path_ptr|
                mode.borrow_c_str(|mode_str|
                    let file_ptr = CALL_C[Ptr fopen(Ptr, Ptr), path_ptr, mode_str];
                    if file_ptr == nullptr { 
                        Result::err $ IOError { msg : "failed to open a file: " + path_str }
                    } else {
                        Result::ok $ IOHandle { _file_ptr : file_ptr }
                    }
                )
            );
            res
        ) }}
    );

    // Print a string to the standard output.
    print : String -> IO ();
    print = |str| (
        IO { _data : |_| (
            let _ = str.borrow_c_str(|c_ptr|
                CALL_C[I32 printf(Ptr, ...), c_ptr]
            );
            ()
        )}
    );

    // Print a string followed by a newline to the standard output.
    println : String -> IO ();
    println = |str| (
        let _ = *print(str);
        let _ = *print("\n");
        pure()
    );

    // Read all characters from a IOHandle.
    read_content : IOHandle -> IOResult IOError String;
    read_content = read_line_inner(false);

    // Raad all characters from a file.
    read_file : Path -> IOResult IOError String;
    read_file = |path| with_file(path, "r", read_content);

    // Read characters from a IOHandle upto newline/carriage return or EOF.
    // The returned string may include newline/carriage return at its end.
    read_line : IOHandle -> IOResult IOError String;
    read_line = read_line_inner(true);

    // Read characters from an IOHandle.
    // if the first argument `upto_newline` is true, this function reads a file upto newline/carriage return or EOF.
    read_line_inner : Bool -> IOHandle -> IOResult IOError String;
    read_line_inner = |upto_newline, handle| (
        IOResult { _data : IO { _data : |_| (
            // Read strings and make iterators of strings (reversed).
            let strings_rev = loop(Iterator::empty, |strs|
                let buf = Array::empty(1024); // NOTE: this number also appears at CALL_C[fgets].
                let strlen = buf.borrow_ptr(|buf|
                    // Read characters to buf.
                    let fgets_res = CALL_C[Ptr fgets(Ptr, I32, Ptr), buf, 1024_I32, handle.@_file_ptr];
                    if fgets_res == nullptr { -1 };

                    // Return length.
                    let strlen = CALL_C[I64 strlen(Ptr), buf];
                    strlen
                );
                // If reached to EOF (or error), break.
                if strlen == -1 { break $ strs };

                // Create string.
                let buf = buf.__unsafe_set_length(strlen + 1);
                let str = String { _data : buf };
                let strs = strs.push_front(str);

                // If no character is read, break.
                if strlen == 0 { break $ strs };

                if upto_newline {
                    // If the last character is \n or \r, break.
                    let last_byte = buf.get(strlen-1);
                    if last_byte == '\n' || last_byte == '\r' { break $ strs };
                    continue $ strs
                } else {
                    continue $ strs
                }
            );

            // Check if err occurred.
            let err = CALL_C[I32 ferror(Ptr), handle.@_file_ptr];
            if err != 0_I32 { 
                let err = IOError { msg : "Std::IO::read_line failed!: some error occurred in fgets." };
                Result::err(err)
            };

            let str = strings_rev.reverse.concat_iter;
            Result::ok(str)
        ) }}
    );

    // Perform a function with a file handle. The second argument is a mode string for `fopen` C function. 
    // The file handle will be closed automatically.
    with_file : Path -> String -> (IOHandle -> IOResult IOError a) -> IOResult IOError a;
    with_file = |path, mode, action| (
        let handle = *open_file(path, mode);
        let res = *action(handle);
        let _ = *IOResult::lift(close_file(handle));
        pure $ res
    );  

    // Write a string into an IOHandle.
    write_content : IOHandle -> String -> IOResult IOError ();
    write_content = |handle, content| (
        let res = content.borrow_c_str(|c_str| (
            let res = CALL_C[I32 fputs(Ptr, Ptr), c_str, handle.@_file_ptr];
            if res < 0_I32 { Result::err $ IOError { msg : "Std::IO::write_content! failed!: some error occurred in fputs." } };
            Result::ok()
        ));
        IOResult::from_result $ res
    );

    // Write a string into a file.
    write_file : Path -> String -> IOResult IOError ();
    write_file = |path, content| with_file(path, "w", |handle| write_content(handle, content));
}

impl IO : Functor {
    map = |f, io| IO { _data : |_| f(io.__unsafe_perform) };
}

impl IO : Monad {
    pure = |v| IO { _data : |_| v };
    bind = |f, io| (
        IO { _data : |_| (
            let a = io.__unsafe_perform;
            f(a).__unsafe_perform
        )}
    );
}

impl IOError : ToString {
    to_string = |e| e.@msg;
}

namespace IO {
    // A handle type for read / write operations on files/stdin/stdout/stderr.
    type IOHandle = unbox struct { _file_ptr: Ptr };
}

namespace IO {
    // A type for I/O error.
    type IOError = unbox struct { msg : String };
}

namespace IO {
    type IOResult e a = unbox struct { _data : IO (Result e a) };
}

namespace IO::IOResult {
    // Create a constant IOResult from a Result value.
    from_result : Result e a -> IOResult e a;
    from_result = |res| IOResult { _data : pure(res) };

    // Lift an IO action to a successful IOResult.
    lift : IO a -> IOResult e a;
    lift = |io| IOResult { _data : io.map(pure) };

    // Convert to an IO value.
    to_io : IOResult e a -> IO (Result e a);
    to_io = @_data;
}

impl IOResult e : Functor {
    map = |f, ior| ior.mod__data(map(map(f)));
}

impl IOResult e : Monad {
    pure = |v| IOResult { _data : pure(pure(v)) };
    bind = |f, ior| IOResult { _data : do {
        let res = *ior.@_data;
        if res.is_err { pure $ Result::err $ res.as_err };
        f(res.as_ok).@_data
    }};
}

namespace IO::IOHandle {

    // The handle for standard error.
    stderr : IOHandle;
    stderr = (
        let ptr = "a".borrow_c_str(|mode| CALL_C[Ptr fdopen(I32, Ptr), 2_I32, mode]);
        IOHandle { _file_ptr: ptr } 
    );

    // The handle for standard input.
    stdin : IOHandle;
    stdin = (
        let ptr = "r".borrow_c_str(|mode| CALL_C[Ptr fdopen(I32, Ptr), 0_I32, mode]);
        IOHandle { _file_ptr: ptr } 
    );

    // The handle for standard output.
    stdout : IOHandle;
    stdout = (
        let ptr = "a".borrow_c_str(|mode| CALL_C[Ptr fdopen(I32, Ptr), 1_I32, mode]);
        IOHandle { _file_ptr: ptr } 
    );
}

// Iterator (a.k.a lazy list)
type Iterator a = unbox struct { next: () -> Option (a, Iterator a) };

namespace Iterator {

    // Flatten an iterator of iterators.
    // You should use `Monad::flatten` instead of this function.
    // This function is used in the implementation of `Monad::bind` for `Iterator`.
    _flatten : Iterator (Iterator a) -> Iterator a;
    _flatten = |iter_iter| (
        let next = |_| (
            if iter_iter.is_empty { Option::none() };
            let (iter, iter_iter) = iter_iter.advance.as_some;
            if iter.is_empty { iter_iter._flatten.advance };
            let (e, iter) = iter.advance.as_some;
            Option::some $ (e, iter_iter.push_front(iter)._flatten)
        );
        Iterator { next : next }
    );

    // Get next value and next iterator.
    advance : Iterator a -> Option (a, Iterator a);
    advance = |iter| (iter.@next)();

    // Append an iterator to a iterator.
    // Note: Since `iter1.append(iter2)` puts `iter2` after `iter1`, `append(lhs, rhs)` puts `lhs` after `rhs`.
    append : Iterator a -> Iterator a -> Iterator a;
    append = |rhs, lhs| (
        if lhs.is_empty { rhs };
        let next = |_| (
            lhs.advance.map(|(e, lhs)| (e, lhs.append(rhs)))
        );
        Iterator { next : next }
    );

    // Evaluate all elements of iterator.
    // TODO: add test
    bang : Iterator a -> Iterator a;
    bang = |iter| iter.to_array.to_iter;

    // Creates an iterator that counts up from a number.
    // count_up(n) = [n, n+1, n+2, ...]
    count_up : I64 -> Iterator I64;
    count_up = |i| (
        let next = |_| (
            some $ (i, Iterator::count_up(i+1))
        );
        Iterator { next: next }
    );

    // Create an empty iterator.
    empty : Iterator a;
    empty = (
        let next = |_| (none());
        Iterator { next: next }
    );

    // Get the first element of an iterator. If the iterator is empty, this function returns `none`.
    // TODO: add test
    get_first : Iterator a -> Option a;
    get_first = |iter| iter.advance.map(@0);

    // Count the number of elements of an iterator.
    get_size : Iterator a -> I64;
    get_size = fold(0, |acm, _| acm + 1);

    // Remove the first element from an iterator. If the iterator is empty, this function returns `none`.
    // TODO: add test
    get_tail : Iterator a -> Option (Iterator a);
    get_tail = |iter| iter.advance.map(@1);

    // Intersperse an elemnt between elements of an iterator.
    // Example: 
    // ```
    // Iterator::from_array([1,2,3]).intersperse(0) == Iterator::from_array([1,0,2,0,3])
    // ```
    intersperse : a -> Iterator a -> Iterator a;
    intersperse = |sep, iter| (
        let next = |_| (
            if iter.is_empty { Option::none() };
            let (e, tail) = iter.advance.as_some;
            if tail.is_empty { Option::some $ (e, Iterator::empty) };
            Option::some $ (e, Iterator::push_front(sep) $ tail.intersperse(sep))
        );
        Iterator { next : next }
    );

    // Check if the iterator is empty.
    is_empty : Iterator a -> Bool;
    is_empty = |iter| iter.advance.is_none;

    // Create a range iterator, i.e. an iterator of the form `[a, a+1, a+2, ..., b-1]`.
    range : I64 -> I64 -> Iterator I64;
    range = |a, b| (
        let next = |_| (
            if a == b {
                Option::none()
            } else {
                Option::some $ (a, Iterator::range(a+1, b))
            }
        );
        Iterator { next: next }
    );

    // Filter elements by a condition function
    filter : (a -> Bool) -> Iterator a -> Iterator a;
    filter = |cond, iter| (
        let next = |_| (
            loop(iter, |iter| (
                let next = iter.advance;
                if next.is_none { break $ none() };
                let (v, iter) = next.as_some;
                if !cond(v) { continue $ iter };
                let iter = filter(cond, iter);
                break $ some((v, iter))
            ))
        );
        Iterator { next: next }
    );

    // Folds iterator from left to right.
    // Example: `fold(init, op, [a0, a1, a2, ...]) = ...op(op(op(init, a0), a1), a2)...`
    fold : b -> (b -> a -> b) -> Iterator a -> b;
    fold = |init, op, iter| (
        loop((init, iter), |(accum, iter)|
            let next = iter.advance;
            if next.is_none {
                break $ accum
            } else {
                let (next, iter) = next.as_some;
                continue $ (op(accum, next), iter)
            }
        )
    );

    // Folds iterator from left to right by monadic action.
    fold_m : [m : Monad] b -> (b -> a -> m b) -> Iterator a -> m b;
    fold_m = |init, op, iter| (
        loop_m((init, iter), |(accum, iter)| (
            let next = iter.advance;
            if next.is_none { break_m $ accum };
            let (next, iter) = next.as_some;
            let accum = *op(accum, next);
            continue_m $ (accum, iter)
        ))
    );

    // Loop along an iterator. At each iteration step, you can choose to continue or to break.
    // TODO: add test.
    for_loop : b -> (b -> a -> LoopResult b b) -> Iterator a -> b;
    for_loop = |init, op, iter| (
        loop((init, iter), |(accum, iter)|
            let next = iter.advance;
            if next.is_none { break $ accum };
            let (next, iter) = next.as_some;
            let loop_res = op(accum, next);
            if loop_res.is_break { break $ loop_res.as_break };
            continue $ (loop_res.as_continue, iter)
        )
    );

    // Loop by monadic action along an iterator. At each iteration step, you can choose to continue or to break.
    // TODO: add test.
    for_loop_m : [m : Monad] b -> (b -> a -> m (LoopResult b b)) -> Iterator a -> m b;
    for_loop_m = |init, op, iter| (
        loop_m((init, iter), |(accum, iter)|
            let next = iter.advance;
            if next.is_none { break_m $ accum };
            let (next, iter) = next.as_some;
            let loop_res = *op(accum, next);
            if loop_res.is_break { break_m $ loop_res.as_break };
            continue_m $ (loop_res.as_continue, iter)
        )
    );

    // Create iterator from an array.
    from_array : Array a -> Iterator a;
    from_array = |arr| count_up(0).take(arr.get_size).map(|i| arr.get(i));

    // Creates iterator from mapping function.
    // from_map(f) = [f(0), f(1), f(2), ...]
    from_map : (I64 -> a) -> Iterator a;
    from_map = |f| count_up(0).map(f);
    
    // Generate an iterator from a state transition function.
    // - if `f(s)` is none, `generate(s, f)` is empty.
    // - if `f(s)` is some value `(e, s1)`, then `generate(s, f)` starts by `e` followed by `generate(s2, f)`.
    generate : s -> (s -> Option (a, s)) -> Iterator a;
    generate = |s, f| (
        let next = |_| f(s).map(|(e, s)| (e, Iterator::generate(s, f)));
        Iterator { next: next }
    );

    // Push an elemnt to an iterator.
    push_front : a -> Iterator a -> Iterator a;
    push_front = |elem, iter| (
        let next = |_| (
            some $ (elem, iter)
        );
        Iterator { next: next }     
    );

    // Reverse an iterator.
    reverse : Iterator a -> Iterator a;
    reverse = |iter| (
        loop((Iterator::empty, iter), |(out_iter, in_iter)|(
            if in_iter.is_empty {
                break $ out_iter
            } else {
                let (elem, in_iter) = in_iter.advance.as_some;
                let out_iter = out_iter.push_front(elem);
                continue $ (out_iter, in_iter)
            }
        ))
    );

    // Take at most n elements from an iterator.
    take : I64 -> Iterator a -> Iterator a;
    take = |n, iter| (
        let next = |_| (
            if n == 0 { none() };
            let iter_next = iter.advance;
            if iter_next.is_none { none() };
            let (v, iter) = iter_next.as_some;
            some $ (v, iter.take(n-1))
        );
        Iterator { next: next }
    );

    // Take elements of an iterator while a condition is satisfied.
    // TODO: add test
    take_while : (a -> Bool) -> Iterator a -> Iterator a;
    take_while = |cond, iter| (
        let next = |_| (
            let iter_next = iter.advance;
            if iter_next.is_none { none() };
            let (v, iter) = iter_next.as_some;
            if !cond(v) { none() };
            some $ (v, iter.take_while(cond))
        );
        Iterator { next: next }        
    );

    // Find the last element of an iterator.
    find_last : Iterator a -> Option a;
    find_last = |iter| (
        if iter.is_empty { none() };
        let (elem, iter) = iter.advance.as_some;
        if iter.is_empty { 
            some(elem)
        } else {
            iter.find_last
        }
    );

    // Convert an iterator to an array.
    to_array : Iterator a -> Array a;
    to_array = Array::from_iter;

    // Zip two iterators.
    zip : Iterator b -> Iterator a -> Iterator (a, b);
    zip = |iter0, iter1| (
        let next = |_| (
            let iter0_next = iter0.advance;
            if iter0_next.is_none { none() };
            let iter1_next = iter1.advance;
            if iter1_next.is_none { none() };
            let (v0, iter0) = iter0_next.as_some;
            let (v1, iter1) = iter1_next.as_some;
            some $ ((v1, v0), zip(iter0, iter1))
        );
        Iterator { next: next }
    );
}

impl Iterator a : Add {
    add = |lhs, rhs| lhs.append(rhs);
}

impl [a : Eq] Iterator a : Eq {
    eq = |lhs, rhs| (
        if lhs.is_empty { rhs.is_empty };
        if rhs.is_empty { false };
        let (e, lhs) = lhs.advance.as_some;
        let (f, rhs) = rhs.advance.as_some;
        if e != f { false };
        lhs == rhs
    );
}

impl Iterator : Functor {
    map = |f, a_iter| (
        let next = |_| (
            a_iter.advance.map(
                |(a_val, a_iter)| (f(a_val), a_iter.map(f))
            )
        );
        Iterator { next: next }
    );
}

impl Iterator : Monad {
    pure = |e| Iterator::empty.push_front(e);
    bind = |f, xs| xs.map(f)._flatten;
}

namespace LoopResult {

    // Make a break value wrapped in a monad.
    // This is used with `loop_m` function.
    break_m : [m : Monad] r -> m (LoopResult s r);
    break_m = break >> pure;

    // Make a continue value wrapped in a monad.
    // This is used with `loop_m` function.
    continue_m : [m : Monad] s -> m (LoopResult s r);
    continue_m = continue >> pure;

}

type Option a = union { none: (), some: a };

namespace Option {

    // Unwrap an option value if it is `some`, or returns given default value if it is `none`.
    as_some_or : a -> Option a -> a;
    as_some_or = |def, opt| (
        if opt.is_none { def } else { opt.as_some }
    );

}

impl [a : Eq] Option a : Eq {
    eq = |lhs, rhs| (
        if lhs.is_some && rhs.is_some { lhs.as_some == rhs.as_some };
        lhs.is_none && rhs.is_none
    );
}

impl Option : Functor {
    map = |f, opt| (
        if opt.is_none {
            Option::none()
        } else {
            Option::some $ f $ opt.as_some
        }
    );
}

impl Option : Monad {
    pure = Option::some;
    bind = |f, opt| if opt.is_none { Option::none() } else { f(opt.as_some) };
}

// The type for file path.
// TODO: give right implementation.
type Path = unbox struct { _data: String };

namespace Path {

    // Parse a string.
    parse : String -> Option Path;
    parse = |s| Option::some $ Path { _data: s };

}

impl Path : ToString {
    to_string = @_data;
}

// A type of result value for a computation that may fail.
type Result e o = unbox union { ok : o, err: e };

namespace Result {

    // Returns the containing value if the value is ok, or otherwise panics after printing the error value.
    unwrap : [e : ToString] Result e o -> o;
    unwrap = |res| (
        if res.is_err {
            let _ = debug_print(res.as_err.to_string);
            abort()
        } else {
            res.as_ok
        }
    );
}

impl Result e : Functor {
    map = |f, res| (
        if res.is_err {
            Result::err $ res.as_err
        } else {
            Result::ok $ f $ res.as_ok
        }
    );
}

impl Result e : Monad {
    pure = Result::ok;
    bind = |f, res| if res.is_err { Result::err $ res.as_err } else { f(res.as_ok) };
}

type String = unbox struct { _data : Array U8 };

namespace String {

    // Get the null-terminated C string.
    // Note that in case the string is not used after call of this function, the returned pointer will be already released.
    _get_c_str : String -> Ptr;
    _get_c_str = |s| s.@_data._get_ptr;

    // Call a function with a null-terminated C string.
    borrow_c_str : (Ptr -> a) -> String -> a;
    borrow_c_str = |f, str| str.@_data.borrow_ptr(f);

    // Concatenate two strings.
    // Note: Since `s1.concat(s2)` puts `s2` after `s1`, `concat(lhs, rhs)` puts `lhs` after `rhs`.
    concat : String -> String -> String;
    concat = |rhs, lhs| (
        // Remove null terminator from lhs and append rhs.
        String { _data : lhs.@_data.pop_back.append(rhs.@_data) }
    );

    // Concatenate an iterator of strings.
    concat_iter : Iterator String -> String;
    concat_iter = |iter| (
        let len = iter.map(get_size).fold(0, add);
        let data_len = len + 1; // Add space for null terminator.
        let data = "".@_data.reserve(data_len);
        let data = iter.fold(data, |data, str| data.pop_back.append(str.@_data));
        String { _data : data }
    );

    // Create a string from C string (i.e., null-terminated byte array).
    from_c_str : Array U8 -> String;
    from_c_str = |buf| (
        // Return length.
        let len = buf.borrow_ptr(|ptr| CALL_C[I64 strlen(Ptr), ptr]);
        let buf = buf.__unsafe_set_length(len + 1);
        String { _data : buf }
    );

    // Get the first byte of a string. Returns none if the string is empty.
    get_first_byte : String -> Option U8;
    get_first_byte = |s| (
        if s.is_empty { Option::none() };
        Option::some $ s.@_data.get(0)
    );

    // Get the last byte of a string. Returns none if the string is empty.
    get_last_byte : String -> Option U8;
    get_last_byte = |s| (
        let len = s.get_size;
        if len == 0 { Option::none() };
        Option::some $ s.@_data.get(len - 1)
    );

    // Get the length of a string.
    get_size : String -> I64;
    get_size = |s| s.@_data.get_size - 1; // exclude null terminator

    // Returns if the string is empty or not.
    is_empty : String -> Bool;
    is_empty = |s| s.get_size == 0;

    // Join strings by a separator.
    join : String -> Iterator String -> String;
    join = |sep, strs| (
        strs.intersperse(sep).concat_iter
    );

    // Removes the last byte.
    // If the string is empty, this function does nothing.
    pop_back_byte : String -> String;
    pop_back_byte = |s| (
        if s.is_empty { s };
        s.mod__data(|bytes| bytes.pop_back.pop_back.push_back(0_U8))
    );

    // Removes the last byte of a string while it satisifies the specified condition.
    strip_last_bytes : (U8 -> Bool) -> String -> String;
    strip_last_bytes = |cond, s| (
        loop(s, |s|
            if s.is_empty { break $ s };
            if cond(s.get_last_byte.as_some) { 
                continue $ s.pop_back_byte
            } else {
                break $ s
            }
        )
    );

    // Removes newlines and carriage returns at the end of the string.
    strip_last_newlines : String -> String;
    strip_last_newlines = strip_last_bytes(|c| c == '\n' || c == '\r');

}

impl String : Add {
    // Concatenate two strings.
    add = |lhs, rhs| lhs.concat(rhs);
}

impl String : Eq {
    // Compare two strings.
    eq = |lhs, rhs| (lhs.@_data == rhs.@_data);
}

impl String : Hash {
    hash = |s| s.@_data.hash;
}

impl String : ToString {
    to_string = |s| s;
}

// Function

// Compose two functions. Composition operators `<<` and `>>` is translated to use of `compose`. 
compose : (a -> b) -> (b -> c) -> a -> c;
compose = |f, g, a| g(f(a));

// Monadic loop function. This is similar to `loop` but can be used to perform monadic action at each loop.
loop_m : [m : Monad] s -> (s -> m (LoopResult s r)) -> m r;
loop_m = |s, f| (
    let res = *f(s);
    if res.is_break { pure $ res.as_break };
    loop_m(res.as_continue, f)
);

// Constants

namespace U8 {
    maximum : U8;
    maximum = 255_U8;

    minimum : U8;
    minimum = 0_U8;
}

namespace I32 {
    maximum : I32;
    maximum = 2147483647_I32;

    minimum : I32;
    minimum = -2147483648_I32;
}

namespace U32 {
    maximum : U32;
    maximum = 4294967295_U32;

    minimum : U32;
    minimum = 0_U32;
}

namespace I64 {
    maximum : I64;
    maximum = 9223372036854775807;

    minimum : I64;
    minimum = -9223372036854775808;
}

namespace U64 {
    maximum : U64;
    maximum = 18446744073709551615_U64;

    minimum : U64;
    minimum = 0_U64;
}

// Traits

trait [f : *->*] f : Functor {
    map : (a -> b) -> f a -> f b;
}

trait a : Hash {
    hash : a -> U64;
}

namespace LessThan {
    max : [a : LessThan] a -> a -> a;
    max = |x, y| if x < y { y } else { x };

    min : [a : LessThan] a -> a -> a;
    min = |x, y| if x < y { x } else { y };
}

trait [m : *->*] m : Monad {
    bind : (a -> m b) -> m a -> m b;
    pure : a -> m a;
}

namespace Monad {
    flatten : [m : Monad] m (m a) -> m a;
    flatten = Monad::bind(|x|x);
}

trait a : ToString {
    to_string : a -> String;
}

// Abs

namespace I32 {
    abs : I32 -> I32;
    abs = |f| if f < 0_I32 { -f } else { f };
}

namespace I64 {
    abs : I64 -> I64;
    abs = |f| if f < 0 { -f } else { f };
}

namespace F32 {
    abs : F32 -> F32;
    abs = |f| if f < 0.0_F32 { -f } else { f };
}

namespace F64 {
    abs : F64 -> F64;
    abs = |f| if f < 0.0 { -f } else { f };
}

// ToString implementations for fundamental types

impl U8 : ToString {
    to_string = U8::_U8_to_string;
}

impl U32 : ToString {
    to_string = U32::_U32_to_string;
}

impl U64 : ToString {
    to_string = U64::_U64_to_string;
}

impl F32 : ToString {
    to_string = |f| f.to_F64.to_string;
}

impl F64 : ToString {
    to_string = F64::_F64_to_string;
}

impl [a : ToString, b : ToString] (a, b) : ToString {
    to_string = |(l, r)| "(" + l.to_string + ", " + r.to_string + ")";
}

// Eq Implementation for fundamental types

impl [a : Eq, b : Eq] (a, b) : Eq {
    eq = |(a, b), (c, d)| a == c && b == d;
}

// Hash Implementation for fundamental types

impl U8 : Hash {
    hash = |x| x.to_U64.hash;
}

impl U64 : Hash {
    hash = |x| (
        // https://stackoverflow.com/questions/664014/what-integer-hash-function-are-good-that-accepts-an-integer-hash-key
        let x = x.bit_xor(x.shift_right(30_U64)) * 13787848793156543929_U64;
        let x = x.bit_xor(x.shift_right(27_U64)) * 10723151780598845931_U64;
        x.bit_xor(x.shift_right(31_U64))
    );
}

impl I64 : Hash {
    hash = I64::to_U64 >> hash;
}

impl [a : Hash, b : Hash] (a, b) : Hash {
    hash = |(a, b)| [a.hash, b.hash].hash;
}