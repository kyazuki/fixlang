module Std;

namespace Array {

    // Append an array to an array.
    // Note: Since `a1.append(a2)` puts `a2` after `a1`, `append(lhs, rhs)` puts `lhs` after `rhs`.
    append : Array a -> Array a -> Array a;
    append = |v2, v1| (
        // if v2 is empty, return early to avoid unnecessary clone.
        let v2_len = v2.get_length;
        if v2_len == 0 { v1 };

        // if v1 is empty, return early to avoid unnecessary clone.
        let v1_len = v1.get_length;
        if v1_len == 0 { v2 };

        // Reserve v1's buffer and force uniqueness.
        let len = v1_len + v2_len;
        let v1 = v1.reserve(len).force_unique;
        
        // Set length.
        let v1 = v1.__unsafe_set_length(len);

        // Copy elements of v2 to v1.
        loop((0, v1), |(idx, v1)|(
            if idx >= v2_len { break $ v1 };
            let v1 = v1.__unsafe_set(v1_len + idx, v2.get(idx));
            continue $ (idx+1, v1)
        ))
    );

    // Call a function with a valid pointer to the memory region where elements are stored.
    call_with_valid_ptr : (Ptr -> b) -> Array a -> b;
    call_with_valid_ptr = |f, arr| (
        let res = f(arr._get_ptr);
        let _ = arr; // Use array after calling f
        res
    );

    // Creates an array by a mapping function.
    from_map : I64 -> (I64 -> a) -> Array a;
    from_map = |size, map| (
        let arr = Array::make_empty(size).__unsafe_set_length(size);
        loop((0, arr), |(idx, arr)|(
            if idx == size {
                break $ arr
            } else {
                let arr = arr.__unsafe_set(idx, map(idx));
                continue $ (idx + 1, arr)
            }
        ))
    );

    // Get the first element of an array. Returns none if the array is empty.
    get_first : Array a -> Option a;
    get_first = |arr| (
        if arr.is_empty { Option::none() };
        Option::some $ arr.get(0)
    );

    // Get the last element of an array. Returns none if the array is empty.
    get_last : Array a -> Option a;
    get_last = |arr| (
        let len = arr.get_length;
        if len == 0 { Option::none() };
        Option::some $ arr.get(len - 1)
    );

    // Returns if the array is empty
    is_empty : Array a -> Bool;
    is_empty = |arr| ( arr.get_length == 0 );

    // Pop an element at the back of an array.
    // If the array is empty, this function does nothing.
    pop_back : Array a -> Array a;
    pop_back = |arr| (
        let len = arr.get_length;
        if len == 0 { arr };
        let arr = arr.force_unique;
        let released_elem = arr.__unsafe_get(len-1);
        arr.__unsafe_set_length(len-1)
    );

    // Push an element to the back of an array.
    push_back : a -> Array a -> Array a;
    push_back = |e, arr| (
        let len = arr.get_length;
        let arr = if arr.get_capacity < len + 1 {
            arr.reserve(2*(len + 1))
        } else {
            arr
        };
        let arr = arr.force_unique.__unsafe_set_length(len+1);
        arr.__unsafe_set(len, e)
    );

    // Reduce the length of an array.
    reduce_length : I64 -> Array a -> Array a;
    reduce_length = |length, vec| (
        loop(vec, |vec|(
            if length >= vec.get_length { break $ vec };
            continue $ vec.pop_back
        ))
    );

    // Reserves the memory region for an array.
    // TODO: change to more optimized implementation.
    reserve : I64 -> Array a -> Array a;
    reserve = |cap, arr| (
        if cap <= arr.get_capacity { arr };
        let len = arr.get_length;
        let new = Array::make_empty(cap).__unsafe_set_length(len);
        loop((0, new), |(idx, new)|(
            if idx == len {
                break $ new
            } else {
                let new = new.__unsafe_set(idx, arr.get(idx));
                continue $ (idx + 1, new)
            }
        ))
    );

    // Sort elements in a vector by "less than" comparator.
    sort_by : ((a, a) -> Bool) -> Array a -> Array a;
    sort_by = |less_than, vec| (
        let buffer = Array::make_empty(vec.get_length);
        let (vec, buffer) = vec._sort_range_by_using_buffer(buffer, 0, vec.get_length, less_than);
        vec
    );

    // Sort elements in a range of a vector by "less than" comparator.
    // This function receives a working buffer as the first argument to reduce memory allocation, and returns it as second element.
    _sort_range_by_using_buffer : Array a -> I64 -> I64 -> ((a, a) -> Bool) -> Array a -> (Array a, Array a);
    _sort_range_by_using_buffer = |buffer, begin, end, less_than, vec| (
        // Merge sorting.
        let len = end - begin;
        if len <= 1 { (vec, buffer) };
        // Divide into intervals.
        let former_len = len / 2;
        let former_begin = begin;
        let former_end = begin + former_len;
        let latter_len = len - former_len;
        let latter_begin = former_end;
        let latter_end = end;
        let (vec, buffer) = vec._sort_range_by_using_buffer(buffer, former_begin, former_end, less_than);
        let (vec, buffer) = vec._sort_range_by_using_buffer(buffer, latter_begin, latter_end, less_than);
        // Merge former and latter to buffer.
        let buffer = buffer.reduce_length(0);
        let former_pos = former_begin;
        let latter_pos = latter_begin;
        let buffer = loop((former_pos, latter_pos, buffer), |(former_pos, latter_pos, buffer)|(
            if former_pos == former_end { // If former_pos reached to the end,
                if latter_pos == latter_end { break $ buffer };
                // Copy elements in latter to buffer.
                let buffer = buffer.push_back(vec.get(latter_pos));
                continue $ (former_pos, latter_pos + 1, buffer)
            };
            if latter_pos == latter_end { // If latter_pos reached to the end,
                // Copy elements in former to buffer.
                let buffer = buffer.push_back(vec.get(former_pos));
                continue $ (former_pos + 1, latter_pos, buffer)
            };
            let former_elem = vec.get(former_pos);
            let latter_elem = vec.get(latter_pos);
            if less_than((former_elem, latter_elem)) {
                // Copy elements in former to buffer.
                let buffer = buffer.push_back(former_elem);
                continue $ (former_pos + 1, latter_pos, buffer)
            } else {
                // Copy elements in latter to buffer.
                let buffer = buffer.push_back(latter_elem);
                continue $ (former_pos, latter_pos + 1, buffer)
            }
        ));
        // Copy buffer to vec.
        loop((0, vec), |(idx, vec)|(
            if idx == len { break $ (vec, buffer) };
            let vec = vec.set(begin + idx, buffer.get(idx));
            continue $ (idx + 1, vec)
        ))
    );

}

impl [a: Eq] Array a : Eq {
    // Compare two vectors.
    eq = |lhs, rhs| (
        if lhs.get_length != rhs.get_length { false };
        let len = lhs.get_length;
        loop(0, |idx| (
            if idx == len { break $ true };
            if lhs.get(idx) != rhs.get(idx) { break $ false };
            continue $ idx + 1
        ))
    );
}

impl Bool : ToString {
    to_string = |lhs| (
        if lhs { "true" } else { "false" }
    );
}

namespace Debug {

    assert_eq : [a: Eq] String -> a -> a -> ();
    assert_eq = |msg, lhs, rhs| assert(msg, lhs == rhs);

    assert : String -> Bool -> ();
    assert = |msg, b| (
        if !b {
            let u = debug_println("assertion failed!: ");
            let u = debug_println(msg);
            abort()
        } else {
            ()
        }
    );

    debug_println : String -> ();
    debug_println = |str| (
        let _ = debug_print(str);
        debug_print("\n")
    );
}

trait [f : *->*] f : Functor {
    map : (a -> b) -> f a -> f b;
}

impl I32 : ToString {
    to_string = I32::_I32_to_string;
}

impl I64 : ToString {
    to_string = I64::_I64_to_string;
}

type IO a = unbox struct { _data : () -> a };

namespace IO {
    // Perform the I/O action. This may violate purity of Fix.
    __unsafe_perform : IO a -> a;
    __unsafe_perform = |io| (io.@_data)();

    // Close a file.
    close_file : IOHandle -> IO ();
    close_file = |handle| (
        IO { _data : |_|(
            let _ = CALL_C[I32 fclose(Ptr), handle.@_file_ptr];
            ()
        ) }
    );

    // Open a file. The second argument is a mode string for `fopen` C function. 
    open_file : Path -> String -> IO (Result IOHandle IOError);
    open_file = |path, mode| (
        IO { _data : |_|(
            let path_str = path.to_string;
            let res = path_str.call_with_valid_c_str(|path_ptr|
                mode.call_with_valid_c_str(|mode_str|
                    let file_ptr = CALL_C[Ptr fopen(Ptr, Ptr), path_ptr, mode_str];
                    if file_ptr == nullptr { 
                        Result::err $ IOError { msg : "failed to open a file: " + path_str }
                    } else {
                        Result::ok $ IOHandle { _file_ptr : file_ptr }
                    }
                )
            );
            res
        ) }
    );

    // Print a string to the standard output.
    print : String -> IO ();
    print = |str| (
        IO { _data : |_| (
            let _ = str.call_with_valid_c_str(|c_ptr|
                CALL_C[I32 printf(Ptr, ...), c_ptr]
            );
            ()
        )}
    );

    // Print a string followed by a newline to the standard output.
    println : String -> IO ();
    println = |str| (
        let _ = print(str)?;
        let _ = print("\n")?;
        pure()
    );

    // Read all characters from a IOHandle.
    read_content : IOHandle -> IO (Result String IOError);
    read_content = read_line_inner(false);

    // Raad all characters from a file.
    read_file : Path -> IO (Result String IOError);
    read_file = |path| (
        let res = with_file(path, "r", read_content)?;
        pure $ res.flatten
    );

    // Read characters from a IOHandle upto newline/carriage return or EOF.
    // The returned string may include newline/carriage return at it's end.
    read_line : IOHandle -> IO (Result String IOError);
    read_line = read_line_inner(true);

    // Read characters from an IOHandle.
    // if the first argument `upto_newline` is true, this function reads a file upto newline/carriage return or EOF.
    read_line_inner : Bool -> IOHandle -> IO (Result String IOError);
    read_line_inner = |upto_newline, handle| (
        IO { _data : |_| (
            // Read strings and make iterators of strings (reversed).
            let strings_rev = loop(Iterator::make_empty, |strs|
                let buf = Array::make_empty(1024); // NOTE: this number also appears at CALL_C[fgets].
                let strlen = buf.call_with_valid_ptr(|buf|
                    // Read characters to buf.
                    let fgets_res = CALL_C[Ptr fgets(Ptr, I32, Ptr), buf, 1024_I32, handle.@_file_ptr];
                    if fgets_res == nullptr { -1 };

                    // Return length.
                    let strlen = CALL_C[I64 strlen(Ptr), buf];
                    strlen
                );
                // If reached to EOF (or error), break.
                if strlen == -1 { break $ strs };

                // Create string.
                let buf = buf.__unsafe_set_length(strlen + 1);
                let str = String { _data : buf };
                let strs = strs.push_front(str);

                // If no character is read, break.
                if strlen == 0 { break $ strs };

                if upto_newline {
                    // If the last character is \n or \r, break.
                    let last_byte = buf.get(strlen-1);
                    if last_byte == '\n' || last_byte == '\r' { break $ strs };
                    continue $ strs
                } else {
                    continue $ strs
                }
            );

            // Check if err occurred.
            let err = CALL_C[I32 ferror(Ptr), handle.@_file_ptr];
            if err != 0_I32 { 
                let err = IOError { msg : "Std::IOState::read_line failed!: some error occurred in fgets." };
                Result::err(err)
            };

            let str = strings_rev.reverse.concat_iter;
            Result::ok(str)
        ) }
    );

    // Perform a function with a file handle. The second argument is a mode string for `fopen` C function. 
    // The file handle will be closed automatically.
    with_file : Path -> String -> (IOHandle -> IO a) -> IO (Result a IOError);
    with_file = |path, mode, action| (
        let res = open_file(path, mode)?;
        if res.is_err { pure $ Result::err $ res.as_err };
        let handle = res.as_ok;
        let res = action(handle)?;
        let _ = close_file(handle)?;
        pure $ Result::ok $ res
    );

    // Write a string into an IOHandle.
    write_content : IOHandle -> String -> IO (Result () IOError);
    write_content = |handle, content| (
        let res = content.call_with_valid_c_str(|c_str| (
            let res = CALL_C[I32 fputs(Ptr, Ptr), c_str, handle.@_file_ptr];
            if res < 0_I32 { Result::err $ IOError { msg : "Std::IOState::write_content! failed!: some error occurred in fputs." } };
            Result::ok()
        ));
        pure $ res
    );

    // Write a string into a file.
    write_file : Path -> String -> IO (Result () IOError);
    write_file = |path, content| (
        let res = with_file(path, "w", |handle| write_content(handle, content))?;
        pure $ res.flatten
    );
}

impl IO : Functor {
    map = |f, io| IO { _data : |_| f(io.__unsafe_perform) };
}

impl IO : Monad {
    pure = |val| IO { _data : |_| val };
    flatten = |io_io| (
        IO { _data : |_| (
            let io = io_io.__unsafe_perform;
            io.__unsafe_perform
        )}
    );
}

namespace IOState {
    // A type for I/O error.
    type IOError = unbox struct { msg : String };
}


impl IOError : ToString {
    to_string = |e| e.@msg;
}

namespace IOState {
    // A handle type for read / write operations on files/stdin/stdout/stderr.
    type IOHandle = unbox struct { _file_ptr: Ptr };
}

namespace IOState::IOHandle {

    // The handle for standard error.
    stderr : IOHandle;
    stderr = (
        let ptr = "a".call_with_valid_c_str(|mode| CALL_C[Ptr fdopen(I32, Ptr), 2_I32, mode]);
        IOHandle { _file_ptr: ptr } 
    );

    // The handle for standard input.
    stdin : IOHandle;
    stdin = (
        let ptr = "r".call_with_valid_c_str(|mode| CALL_C[Ptr fdopen(I32, Ptr), 0_I32, mode]);
        IOHandle { _file_ptr: ptr } 
    );

    // The handle for standard output.
    stdout : IOHandle;
    stdout = (
        let ptr = "a".call_with_valid_c_str(|mode| CALL_C[Ptr fdopen(I32, Ptr), 1_I32, mode]);
        IOHandle { _file_ptr: ptr } 
    );
}

// Iterator (a.k.a lazy list)
type Iterator a = unbox struct { next: () -> Option (a, Iterator a) };

namespace Iterator {

    // Append an iterator to a iterator.
    // Note: Since `iter1.append(iter2)` puts `iter2` after `iter1`, `append(lhs, rhs)` puts `lhs` after `rhs`.
    append : Iterator a -> Iterator a -> Iterator a;
    append = |rhs, lhs| (
        if lhs.is_empty { rhs };
        let Option::some((e, lhs)) = lhs.advance;
        Iterator::push_front(e) $ lhs.append(rhs)
    );

    // Creates an iterator that counts up from a number.
    // count_up(n) = [n, n+1, n+2, ...]
    count_up : I64 -> Iterator I64;
    count_up = |i| (
        let next = |_| (
            some $ (i, Iterator::count_up(i+1))
        );
        Iterator { next: next }
    );

    // Counts the length of an iterator.
    get_length : Iterator a -> I64;
    get_length = fold(0, |acm, _| acm + 1);

    // I64ersperse an elemnt between elements of an iterator.
    // Example: 
    // ```
    // Iterator::from_array([1,2,3]).intersperse(0) == Iterator::from_array([1,0,2,0,3])
    // ```
    intersperse : a -> Iterator a -> Iterator a;
    intersperse = |sep, iter| (
        if iter.is_empty { Iterator::make_empty };
        let Option::some((e, tail)) = iter.advance;
        if tail.is_empty { iter };
        Iterator::push_front(e) $ Iterator::push_front(sep) $ tail.intersperse(sep)
    );

    // Create an empty iterator.
    make_empty : Iterator a;
    make_empty = (
        let next = |_| (none());
        Iterator { next: next }
    );

    // Filter elements by a condition function
    filter : (a -> Bool) -> Iterator a -> Iterator a;
    filter = |cond, iter| (
        let next = |_| (
            loop(iter, |iter| (
                let next = iter.advance;
                if next.is_none { break $ none() };
                let (v, iter) = next.as_some;
                if !cond(v) { continue $ iter };
                let iter = filter(cond, iter);
                break $ some((v, iter))
            ))
        );
        Iterator { next: next }
    );

    // Folds iterator from left.
    // fold(init, op, [a0, a1, a2, ...]) = ...op(op(op(init, a0), a1), a2)...
    fold : b -> (b -> a -> b) -> Iterator a -> b;
    fold = |init, op, iter| (
        loop((init, iter), |(accum, iter)|
            let next = iter.advance;
            if next.is_none {
                break $ accum
            } else {
                let (next, iter) = next.as_some;
                continue $ (op(accum, next), iter)
            }
        )
    );

    // Create iterator from an array.
    from_array : Array a -> Iterator a;
    from_array = |arr| count_up(0).take(arr.get_length).map(|i| arr.get(i));

    // Creates iterator from mapping function.
    // from_map(f) = [f(0), f(1), f(2), ...]
    from_map : (I64 -> a) -> Iterator a;
    from_map = |f| count_up(0).map(f);

    // Takes the last element of an iterator.
    take_last : Iterator a -> Option a;
    take_last = |iter| (
        if iter.is_empty { none() };
        let (elem, iter) = iter.advance.as_some;
        if iter.is_empty { 
            some(elem)
        } else {
            iter.take_last
        }
    );

    // Checks if an iterator is empty.
    is_empty : Iterator a -> Bool;
    is_empty = |iter| iter.advance.is_none;

    // Get next value and next iterator.
    advance : Iterator a -> Option (a, Iterator a);
    advance = |iter| (iter.@next)();

    // Push an elemnt to an iterator.
    push_front : a -> Iterator a -> Iterator a;
    push_front = |elem, iter| (
        let next = |_| (
            some $ (elem, iter)
        );
        Iterator { next: next }     
    );

    // Reverse an iterator.
    reverse : Iterator a -> Iterator a;
    reverse = |iter| (
        loop((Iterator::make_empty, iter), |(out_iter, in_iter)|(
            if in_iter.is_empty {
                break $ out_iter
            } else {
                let (elem, in_iter) = in_iter.advance.as_some;
                let out_iter = out_iter.push_front(elem);
                continue $ (out_iter, in_iter)
            }
        ))
    );

    // Take at most n elements from an iterator.
    take : I64 -> Iterator a -> Iterator a;
    take = |n, iter| (
        let next = |_| (
            if n == 0 { none() };
            let iter_next = iter.advance;
            if iter_next.is_none { none() };
            let (v, iter) = iter_next.as_some;
            some $ (v, iter.take(n-1))
        );
        Iterator { next: next }
    );

    // Zip two iterators.
    zip : Iterator a -> Iterator b -> Iterator (a, b);
    zip = |iter0, iter1| (
        let next = |_| (
            let iter0_next = iter0.advance;
            if iter0_next.is_none { none() };
            let iter1_next = iter1.advance;
            if iter1_next.is_none { none() };
            let (v0, iter0) = iter0_next.as_some;
            let (v1, iter1) = iter1_next.as_some;
            some $ ((v0, v1), zip(iter0, iter1))
        );
        Iterator { next: next }
    );
}

impl Iterator a : Add {
    add = |lhs, rhs| lhs.append(rhs);
}

impl [a : Eq] Iterator a : Eq {
    eq = |lhs, rhs| (
        if lhs.is_empty { rhs.is_empty };
        if rhs.is_empty { false };
        let Option::some((e, lhs)) = lhs.advance;
        let Option::some((f, rhs)) = rhs.advance;
        if e != f { false };
        lhs == rhs
    );
}

impl Iterator : Functor {
    map = |f, a_iter| (
        let next = |_| (
            a_iter.advance.map(
                |(a_val, a_iter)| (f(a_val), a_iter.map(f))
            )
        );
        Iterator { next: next }
    );
}

impl Iterator : Monad {
    flatten = |iter| iter.fold(Iterator::make_empty, Add::add);
    pure = |e| Iterator::make_empty.push_front(e);
}

namespace Monad {
    bind : [m : Monad, m : Functor] (a -> m b) -> m a -> m b;
    bind = |f, a| a.map(f).flatten;
}

trait [m : *->*] m : Monad {
    flatten : m (m a) -> m a;
    pure : a -> m a;
}

type Option a = union { none: (), some: a };

impl [a : Eq] Option a : Eq {
    eq = |lhs, rhs| (
        if lhs.is_some && rhs.is_some { lhs.as_some == rhs.as_some };
        lhs.is_none && rhs.is_none
    );
}

impl Option : Functor {
    map = |f, opt| (
        if opt.is_none {
            Option::none()
        } else {
            Option::some $ f $ opt.as_some
        }
    );
}

impl Option : Monad {
    flatten = |opt_opt| (
        if opt_opt.is_none { 
            Option::none()
        } else {
            opt_opt.as_some
        }
    );
    pure = Option::some;
}

// The type for file path.
// TODO: give right implementation.
type Path = unbox struct { _data: String };

namespace Path {

    // Parse a string.
    parse : String -> Option Path;
    parse = |s| Option::some $ Path { _data: s };

}

impl Path : ToString {
    to_string = @_data;
}

// A type of result value for a computation that may fail.
type Result o e = unbox union { ok : o, err: e };

namespace Result {

    // Flatten a nested result.
    flatten : Result (Result o e) e -> Result o e;
    flatten = |res| (
        if res.is_err { Result::err $ res.as_err };
        let res = res.as_ok;
        if res.is_err { Result::err $ res.as_err };
        Result::ok $ res.as_ok
    );

    // Returns the containing value if the value is ok, or otherwise panics after printing error value.
    unwrap : [e : ToString] Result o e -> o;
    unwrap = |res| (
        if res.is_err {
            let _ = debug_print(res.as_err.to_string);
            abort()
        } else {
            res.as_ok
        }
    );
}

type String = unbox struct { _data : Array U8 };

namespace String {
    // Get the null-terminated C string.
    // Note that in case the string is not used after call of this function, the returned pointer will be already released.
    _get_c_str : String -> Ptr;
    _get_c_str = |s| s.@_data._get_ptr;

    // Call a function with a valid null-terminated C string.
    call_with_valid_c_str : (Ptr -> a) -> String -> a;
    call_with_valid_c_str = |f, str| str.@_data.call_with_valid_ptr(f);

    // Concatenate two strings.
    // Note: Since `s1.concat(s2)` puts `s2` after `s1`, `concat(lhs, rhs)` puts `lhs` after `rhs`.
    concat : String -> String -> String;
    concat = |rhs, lhs| (
        // Remove null terminator from lhs and append rhs.
        String { _data : lhs.@_data.pop_back.append(rhs.@_data) }
    );

    // Concatenate an iterator of strings.
    concat_iter : Iterator String -> String;
    concat_iter = |iter| (
        let len = iter.map(get_length).fold(0, add);
        let data_len = len + 1; // Add space for null terminator.
        let data = "".@_data.reserve(data_len);
        let data = iter.fold(data, |data, str| data.pop_back.append(str.@_data));
        String { _data : data }
    );

    // Get the first byte of a string. Returns none if the string is empty.
    get_first_byte : String -> Option U8;
    get_first_byte = |s| (
        if s.is_empty { Option::none() };
        Option::some $ s.@_data.get(0)
    );

    // Get the last byte of a string. Returns none if the string is empty.
    get_last_byte : String -> Option U8;
    get_last_byte = |s| (
        let len = s.get_length;
        if len == 0 { Option::none() };
        Option::some $ s.@_data.get(len - 1)
    );

    // Get the length of a string.
    get_length : String -> I64;
    get_length = |s| s.@_data.get_length - 1; // exclude null terminator

    // Returns if the string is empty or not.
    is_empty : String -> Bool;
    is_empty = |s| s.get_length == 0;

    // Join strings by a separator.
    join : String -> Iterator String -> String;
    join = |sep, strs| (
        strs.intersperse(sep).concat_iter
    );

    // Removes the last byte.
    // If the string is empty, this function does nothing.
    pop_back_byte : String -> String;
    pop_back_byte = |s| (
        if s.is_empty { s };
        s.mod__data(|bytes| bytes.pop_back.pop_back.push_back(0_U8))
    );

    // Removes the last byte of a string while it satisifies the specified condition.
    strip_last_bytes : (U8 -> Bool) -> String -> String;
    strip_last_bytes = |cond, s| (
        loop(s, |s|
            if s.is_empty { break $ s };
            if cond(s.get_last_byte.as_some) { 
                continue $ s.pop_back_byte
            } else {
                break $ s
            }
        )
    );

    // Removes newlines and carriage returns at the end of the string.
    strip_last_newlines : String -> String;
    strip_last_newlines = strip_last_bytes(|c| c == '\n' || c == '\r');

}

impl String : Add {
    // Concatenate two strings.
    add = |lhs, rhs| lhs.concat(rhs);
}

impl String : Eq {
    // Compare two strings.
    eq = |lhs, rhs| (lhs.@_data == rhs.@_data);
}

impl String : ToString {
    to_string = |s| s;
}

trait a : ToU8 {
    to_U8 : a -> U8;
}

trait a : ToI32 {
    to_I32 : a -> I32;
}

trait a : ToU32 {
    to_U32 : a -> U32;
}

trait a : ToI64 {
    to_I64 : a -> I64;
}

trait a : ToU64 {
    to_U64 : a -> U64;
}

trait a : ToString {
    to_string : a -> String;
}

impl U8 : ToString {
    to_string = U8::_U8_to_string;
}

// U8 -> other integral types
impl U8 : ToU8 {
    to_U8 = U8::_cast_U8_to_U8;
}

impl U8 : ToI32 {
    to_I32 = U8::_cast_U8_to_I32;
}

impl U8 : ToU32 {
    to_U32 = U8::_cast_U8_to_U32;
}

impl U8 : ToI64 {
    to_I64 = U8::_cast_U8_to_I64;
}

impl U8 : ToU64 {
    to_U64 = U8::_cast_U8_to_U64;
}

// I32 -> other integral types
impl I32 : ToU8 {
    to_U8 = I32::_cast_I32_to_U8;
}

impl I32 : ToI32 {
    to_I32 = I32::_cast_I32_to_I32;
}

impl I32 : ToU32 {
    to_U32 = I32::_cast_I32_to_U32;
}

impl I32 : ToI64 {
    to_I64 = I32::_cast_I32_to_I64;
}

impl I32 : ToU64 {
    to_U64 = I32::_cast_I32_to_U64;
}

// U32 -> other integral types
impl U32 : ToU8 {
    to_U8 = U32::_cast_U32_to_U8;
}

impl U32 : ToI32 {
    to_I32 = U32::_cast_U32_to_I32;
}

impl U32 : ToU32 {
    to_U32 = U32::_cast_U32_to_U32;
}

impl U32 : ToI64 {
    to_I64 = U32::_cast_U32_to_I64;
}

impl U32 : ToU64 {
    to_U64 = U32::_cast_U32_to_U64;
}

// I64 -> other integral types
impl I64 : ToU8 {
    to_U8 = I64::_cast_I64_to_U8;
}

impl I64 : ToI32 {
    to_I32 = I64::_cast_I64_to_I32;
}

impl I64 : ToU32 {
    to_U32 = I64::_cast_I64_to_U32;
}

impl I64 : ToI64 {
    to_I64 = I64::_cast_I64_to_I64;
}

impl I64 : ToU64 {
    to_U64 = I64::_cast_I64_to_U64;
}

// U64 -> other integral types
impl U64 : ToU8 {
    to_U8 = U64::_cast_U64_to_U8;
}

impl U64 : ToI32 {
    to_I32 = U64::_cast_U64_to_I32;
}

impl U64 : ToU32 {
    to_U32 = U64::_cast_U64_to_U32;
}

impl U64 : ToI64 {
    to_I64 = U64::_cast_U64_to_I64;
}

impl U64 : ToU64 {
    to_U64 = U64::_cast_U64_to_U64;
}

impl U32 : ToString {
    to_string = U32::_U32_to_string;
}

impl U64 : ToString {
    to_string = U64::_U64_to_string;
}